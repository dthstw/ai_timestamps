00:00:00 - 00:00:04: [Music]
00:00:02 - 00:00:05: if you're interested in becoming a
00:00:04 - 00:00:07: developer that writes any type of code
00:00:05 - 00:00:09: in Python then you need to understand
00:00:07 - 00:00:11: these five very important python
00:00:09 - 00:00:13: Concepts these are what I see most
00:00:11 - 00:00:15: beginner and intermediate python
00:00:13 - 00:00:17: programmers making a ton of mistakes
00:00:15 - 00:00:19: with and misunderstanding when they're
00:00:17 - 00:00:20: reading through production code the goal
00:00:19 - 00:00:22: of this video is to make sure that when
00:00:20 - 00:00:24: you're reading through production python
00:00:22 - 00:00:25: code you understand what's happening you
00:00:24 - 00:00:27: know the concept and then you can
00:00:25 - 00:00:29: reproduce that code and write your own
00:00:27 - 00:00:31: pull requests and own features using
00:00:29 - 00:00:33: python code that other developers will
00:00:31 - 00:00:35: understand and expect
00:00:33 - 00:00:37: so with that said let's get into the
00:00:35 - 00:00:38: video after I share with you the first
00:00:37 - 00:00:41: very important concept you need to
00:00:38 - 00:00:44: understand which is the sponsor of this
00:00:41 - 00:00:45: video nordpass nordpass is the ultimate
00:00:44 - 00:00:47: password and credential management
00:00:45 - 00:00:49: solution that I've actually been looking
00:00:47 - 00:00:51: for for a long time now I don't know
00:00:49 - 00:00:53: about you guys but I have a lot of
00:00:51 - 00:00:56: passwords credit cards Bank details
00:00:53 - 00:00:58: private Keys Etc and oftentimes I need
00:00:56 - 00:01:00: to share these with my co-workers making
00:00:58 - 00:01:02: it a constant struggle to not only keep
00:01:00 - 00:01:03: this data secure and safe but to allow
00:01:02 - 00:01:06: them to access it quickly without having
00:01:03 - 00:01:07: to message me all the time now nordpass
00:01:06 - 00:01:09: fixes this problem because it allows me
00:01:07 - 00:01:12: to store both my personal or my business
00:01:09 - 00:01:14: data in a single secure location and
00:01:12 - 00:01:16: then give different access to members of
00:01:14 - 00:01:17: my team now if you don't believe me you
00:01:16 - 00:01:18: can check it out from the link in the
00:01:17 - 00:01:20: description and use the code Tech with
00:01:18 - 00:01:22: Tim which means you'll no longer have to
00:01:20 - 00:01:25: be sending messages or receiving
00:01:22 - 00:01:27: messages asking for passwords not to
00:01:25 - 00:01:29: mention the nordpass has features like
00:01:27 - 00:01:31: autofill data breach detection and
00:01:29 - 00:01:34: activity log a password generator and
00:01:31 - 00:01:35: much more check out Nord from the link
00:01:34 - 00:01:38: in the description and use the code
00:01:35 - 00:01:40: tequitim for a three month free trial so
00:01:38 - 00:01:42: you can take control over your data and
00:01:40 - 00:01:45: your accounts thanks again to nordpass
00:01:42 - 00:01:46: for sponsoring this video so the first
00:01:45 - 00:01:48: concept to go over here is mutable
00:01:46 - 00:01:50: versus immutable types now this is the
00:01:48 - 00:01:51: concept that most beginner and
00:01:50 - 00:01:53: intermediate programmers make mistakes
00:01:51 - 00:01:54: with don't worry if you already
00:01:53 - 00:01:56: understand it there's a lot more
00:01:54 - 00:01:58: complicated Concepts so stick around for
00:01:56 - 00:02:00: the rest of the video regardless an
00:01:58 - 00:02:03: immutable type is something that cannot
00:02:00 - 00:02:05: change a mutable type is something that
00:02:03 - 00:02:07: can change an example of these in Python
00:02:05 - 00:02:10: is the following so immutable types are
00:02:07 - 00:02:15: going to be our string our ins our
00:02:10 - 00:02:17: floats our Boolean our bytes type and
00:02:15 - 00:02:19: our topple type all of these are
00:02:17 - 00:02:22: immutable meaning once you define this
00:02:19 - 00:02:24: you cannot change it however we have
00:02:22 - 00:02:27: mutable types in Python which are the
00:02:24 - 00:02:28: list the set and the dictionary and
00:02:27 - 00:02:31: pretty much any other type used from
00:02:28 - 00:02:33: some third-party library or module these
00:02:31 - 00:02:36: can change which means once you find
00:02:33 - 00:02:38: them you can actually modify them let me
00:02:36 - 00:02:40: give you a super quick example here of
00:02:38 - 00:02:42: immutable versus mutable then we'll go
00:02:40 - 00:02:44: into a more complex one using a function
00:02:42 - 00:02:46: which is where I see most beginners make
00:02:44 - 00:02:48: a mistake okay so let's say we have some
00:02:46 - 00:02:50: number like x equals one and we say Y is
00:02:48 - 00:02:53: equal to X and in fact let's change this
00:02:50 - 00:02:56: to a tuple which remember is e mutable
00:02:53 - 00:02:57: meaning we cannot change it actually to
00:02:56 - 00:02:59: quickly show this to you let's try to do
00:02:57 - 00:03:01: something like x0 is equal to one where
00:02:59 - 00:03:04: we're trying to change this Tuple
00:03:01 - 00:03:06: without reassigning something to this
00:03:04 - 00:03:08: variable so if I go here and run my code
00:03:06 - 00:03:10: notice I get an error and it says the
00:03:08 - 00:03:12: Tuple object does not support item
00:03:10 - 00:03:13: assignment now the reason it doesn't
00:03:12 - 00:03:15: support that is because this is
00:03:13 - 00:03:18: immutable that means that once I Define
00:03:15 - 00:03:20: this Tuple I cannot change it now if we
00:03:18 - 00:03:23: go here and do something like Y equals X
00:03:20 - 00:03:24: and let's come and say X
00:03:23 - 00:03:27: is equal
00:03:24 - 00:03:30: to one two three I just want to show you
00:03:27 - 00:03:32: if I print out both X and Y here that my
00:03:30 - 00:03:35: change to X here after assigning X to Y
00:03:32 - 00:03:37: did not affect y the reason for that is
00:03:35 - 00:03:39: whenever you're using immutable types
00:03:37 - 00:03:41: when you do an assignment to another
00:03:39 - 00:03:44: variable so I do something like Y equals
00:03:41 - 00:03:47: X it makes a copy so an actual real copy
00:03:44 - 00:03:49: of this immutable object meaning that if
00:03:47 - 00:03:51: I now go something like X is equal to
00:03:49 - 00:03:54: one two three that's not going to affect
00:03:51 - 00:03:56: y because I'm not modifying what Y is
00:03:54 - 00:03:58: storing I'm just reassigning a new value
00:03:56 - 00:04:00: to X I know that seems trivial but the
00:03:58 - 00:04:02: reason I'm illustrating this to you is
00:04:00 - 00:04:04: because this works differently when we
00:04:02 - 00:04:06: change this to a list
00:04:04 - 00:04:09: so if I change this to a list now and
00:04:06 - 00:04:12: then I come and do something like x 0 is
00:04:09 - 00:04:14: equal to 100
00:04:12 - 00:04:16: you might think that Y is not going to
00:04:14 - 00:04:18: change but when I run this you see that
00:04:16 - 00:04:20: both X and Y have the same value now the
00:04:18 - 00:04:22: reason for that is when you're using
00:04:20 - 00:04:24: mutable types and you do something like
00:04:22 - 00:04:27: Y equals X here so you're signing a
00:04:24 - 00:04:29: variable to another variable and this
00:04:27 - 00:04:30: variable is storing a mutable type what
00:04:29 - 00:04:33: happens is you actually store a
00:04:30 - 00:04:35: reference or an alias to this same
00:04:33 - 00:04:37: object meaning that if I make a change
00:04:35 - 00:04:39: to the object like I'm doing right here
00:04:37 - 00:04:41: it changes for both of these variables
00:04:39 - 00:04:43: because they're actually storing the
00:04:41 - 00:04:45: same object in fact they're storing a
00:04:43 - 00:04:47: reference to the same object so again if
00:04:45 - 00:04:49: you change the underlying object then it
00:04:47 - 00:04:51: changes for both X and Y that's the
00:04:49 - 00:04:53: difference between immutable and mutable
00:04:51 - 00:04:55: types now let me just paste in a quick
00:04:53 - 00:04:56: example here that will illustrate this
00:04:55 - 00:04:58: even a little bit further so you can see
00:04:56 - 00:05:00: in this example we have a function that
00:04:58 - 00:05:02: Returns the largest numbers it Returns
00:05:00 - 00:05:04: the N largest numbers actually what it
00:05:02 - 00:05:06: does is it sorts the list of numbers
00:05:04 - 00:05:08: that it accepts so what I've done down
00:05:06 - 00:05:09: here is I've created a list of numbers I
00:05:08 - 00:05:11: printed out what the value of the list
00:05:09 - 00:05:13: was before I called the function and
00:05:11 - 00:05:15: then I printed out with the value was
00:05:13 - 00:05:16: afterwards now take a guess if you want
00:05:15 - 00:05:18: it what you think the output is going to
00:05:16 - 00:05:20: be but I'll go ahead and run the code
00:05:18 - 00:05:22: and you can see here that we actually
00:05:20 - 00:05:24: get the list before that's unsorted and
00:05:22 - 00:05:26: then the list becomes sorted afterwards
00:05:24 - 00:05:28: now the reason this occurs is because
00:05:26 - 00:05:31: what happens is when we call this
00:05:28 - 00:05:33: function we pass this nums list as the
00:05:31 - 00:05:35: parameter numbers now since we're
00:05:33 - 00:05:38: passing a mutable object a list is
00:05:35 - 00:05:40: mutable when we do a numbers.sort what
00:05:38 - 00:05:43: this does is actually sort the list in
00:05:40 - 00:05:46: place now numbers here is going to be
00:05:43 - 00:05:48: storing a reference to this same list so
00:05:46 - 00:05:51: when I sort the numbers parameter here
00:05:48 - 00:05:53: since I had passed in my numbers array
00:05:51 - 00:05:55: it ends up sorting that numbers array
00:05:53 - 00:05:57: that's down here seems a little bit
00:05:55 - 00:05:59: strange but the reason this is occurring
00:05:57 - 00:06:00: is again because we're using a mutable
00:05:59 - 00:06:02: object so the point here is that you
00:06:00 - 00:06:04: need to understand when you're using
00:06:02 - 00:06:05: mutable versus immutable objects because
00:06:04 - 00:06:08: you could have functions like this that
00:06:05 - 00:06:10: can perform side effects on your mutable
00:06:08 - 00:06:11: objects this is referred to as a side
00:06:10 - 00:06:13: effect because what happens is one of
00:06:11 - 00:06:15: the parameters is being mutated or
00:06:13 - 00:06:17: modified inside of the function
00:06:15 - 00:06:19: sometimes you want that to be the case
00:06:17 - 00:06:20: sometimes you don't want that to be the
00:06:19 - 00:06:22: case you need to be intentional when
00:06:20 - 00:06:23: you're writing your code so the next
00:06:22 - 00:06:25: concept to understand here is list
00:06:23 - 00:06:27: comprehensions now the reason you need
00:06:25 - 00:06:29: to understand this is because it's used
00:06:27 - 00:06:31: quite a bit in Python and oftentimes
00:06:29 - 00:06:33: you'll see people writing fairly
00:06:31 - 00:06:36: complicated comprehensions to simplify a
00:06:33 - 00:06:37: line of code now this can kind of do the
00:06:36 - 00:06:40: reverse sometimes it can actually make
00:06:37 - 00:06:41: it more complicated regardless you need
00:06:40 - 00:06:43: to understand what they are so that you
00:06:41 - 00:06:45: can actually understand them if you see
00:06:43 - 00:06:47: them in some production code so let's
00:06:45 - 00:06:49: have a look at a list comprehension so
00:06:47 - 00:06:51: the most basic comprehension you can do
00:06:49 - 00:06:54: here is something like X or we'll go
00:06:51 - 00:06:57: with i for I in range and then maybe
00:06:54 - 00:06:58: something like 10 and in case you can't
00:06:57 - 00:07:00: guess it here what this is going to do
00:06:58 - 00:07:02: is give me an array that contains the
00:07:00 - 00:07:04: numbers 0 through 9. so let me open up
00:07:02 - 00:07:06: my terminal and run this and there you
00:07:04 - 00:07:08: go we get zero through nine so this is a
00:07:06 - 00:07:10: list comprehension where essentially you
00:07:08 - 00:07:12: write a for Loop inside of a list what
00:07:10 - 00:07:14: you do on the left hand side is you put
00:07:12 - 00:07:16: but the value that you want to populate
00:07:14 - 00:07:17: the list with and then you have some
00:07:16 - 00:07:19: kind of iterator in this case we have a
00:07:17 - 00:07:21: for Loop that's going to Loop through
00:07:19 - 00:07:23: and generate these different values now
00:07:21 - 00:07:25: this is a very simple list comprehension
00:07:23 - 00:07:27: you can make much more complicated ones
00:07:25 - 00:07:30: for example we can have a list here
00:07:27 - 00:07:32: instead so now if I do a list we have a
00:07:30 - 00:07:33: bunch of empty lists inside of this list
00:07:32 - 00:07:35: but just like we have a list
00:07:33 - 00:07:36: comprehension here we can have one
00:07:35 - 00:07:39: inside of this list so I can do
00:07:36 - 00:07:44: something like four so actually let's go
00:07:39 - 00:07:46: with J 4J in range 5 like that and now
00:07:44 - 00:07:48: we have a nested list comprehension and
00:07:46 - 00:07:50: if I run this code you can see that now
00:07:48 - 00:07:53: we get a bunch of lists that contain
00:07:50 - 00:07:55: five different values inside of them 10
00:07:53 - 00:07:58: times okay so that's one thing you can
00:07:55 - 00:08:01: do another thing that we can do here is
00:07:58 - 00:08:03: the following so let's go here and say I
00:08:01 - 00:08:06: for I in range 10 and then we can put in
00:08:03 - 00:08:09: if statement and we can say if I mod 2
00:08:06 - 00:08:11: is equal to zero now this means we're
00:08:09 - 00:08:13: going to only put this value here if
00:08:11 - 00:08:15: this condition evaluate true so in this
00:08:13 - 00:08:18: case we're only going to put even values
00:08:15 - 00:08:19: or 0 inside of this list so when I run
00:08:18 - 00:08:22: this you see that we get all of the even
00:08:19 - 00:08:24: values up to but not including 10. all
00:08:22 - 00:08:26: right so the next concept here is the
00:08:24 - 00:08:28: different python argument and parameter
00:08:26 - 00:08:30: types now there's quite a few that's why
00:08:28 - 00:08:32: I'm going through this concept and a lot
00:08:30 - 00:08:34: of times people have no idea what they
00:08:32 - 00:08:36: are beyond the basic ones so if we
00:08:34 - 00:08:38: Define a function here like complicated
00:08:36 - 00:08:40: function we can have what's known as our
00:08:38 - 00:08:43: necessary parameters or our positional
00:08:40 - 00:08:45: parameters that are defined in order so
00:08:43 - 00:08:46: I can have something like X Y now these
00:08:45 - 00:08:49: are required and they are positional
00:08:46 - 00:08:51: meaning that if I want to pass values
00:08:49 - 00:08:53: here I have to do something like 1 2
00:08:51 - 00:08:55: right I pass them in the order in which
00:08:53 - 00:08:59: I want them to be um kind of assigned so
00:08:55 - 00:09:00: X is 1 and Y is 2. however I can
00:08:59 - 00:09:03: actually switch things up a little bit
00:09:00 - 00:09:07: here and as I pass these arguments I can
00:09:03 - 00:09:09: do something like Y is equal to 2 and X
00:09:07 - 00:09:13: is equal to 1. and now if I go here and
00:09:09 - 00:09:16: print this so X and Y
00:09:13 - 00:09:18: you see that we get one and two so this
00:09:16 - 00:09:19: is valid when you are calling a function
00:09:18 - 00:09:21: you can actually write out the name of
00:09:19 - 00:09:23: the parameter whether or not it's
00:09:21 - 00:09:25: positional optional Etc and then you can
00:09:23 - 00:09:28: just assign it directly inside of here
00:09:25 - 00:09:31: this allows you to no longer pass this
00:09:28 - 00:09:33: positionally however if I pass some
00:09:31 - 00:09:34: positional arguments so let's say I do
00:09:33 - 00:09:37: something like one
00:09:34 - 00:09:40: now I can do something like Z2 Y is
00:09:37 - 00:09:42: equal to 3. so I can pass some of the
00:09:40 - 00:09:44: arguments positionally and then some of
00:09:42 - 00:09:47: them I can pass uh using the kind of
00:09:44 - 00:09:48: keyword argument here or you know the
00:09:47 - 00:09:50: named argument whatever you want to
00:09:48 - 00:09:52: refer to it as by the way inside of your
00:09:50 - 00:09:53: function call you refer to these as
00:09:52 - 00:09:55: arguments and up here in your function
00:09:53 - 00:09:57: you refer to these as parameters so I
00:09:55 - 00:09:58: just wanted to show you that I can pass
00:09:57 - 00:10:00: some of these positionally however
00:09:58 - 00:10:03: things get a little bit weird if I try
00:10:00 - 00:10:05: to pass some positionally and some using
00:10:03 - 00:10:08: the keyword so in this case I have like
00:10:05 - 00:10:09: Z equals 2 1 and then y equals three if
00:10:08 - 00:10:11: I try to run this notice I get an error
00:10:09 - 00:10:13: and it says a positional argument
00:10:11 - 00:10:15: follows a keyword argument which you're
00:10:13 - 00:10:16: not allowed to do so if I want to use
00:10:15 - 00:10:19: some positional arguments and the rest
00:10:16 - 00:10:20: keyword arguments that means that I need
00:10:19 - 00:10:22: to start by defining my positional
00:10:20 - 00:10:24: arguments then I can do the keyword
00:10:22 - 00:10:26: arguments after hopefully that's clear
00:10:24 - 00:10:29: but that was the first thing to go over
00:10:26 - 00:10:31: okay next thing is optional parameters
00:10:29 - 00:10:33: so inside of your function you can mark
00:10:31 - 00:10:35: one of your parameters as optional by
00:10:33 - 00:10:37: putting in equal signs by do Z equals
00:10:35 - 00:10:39: two in this case none now this is
00:10:37 - 00:10:42: optional meaning I'm not required to
00:10:39 - 00:10:44: pass it when I call this function so if
00:10:42 - 00:10:46: I call with 1 and 3 here you can see
00:10:44 - 00:10:48: this is perfectly fine however if I got
00:10:46 - 00:10:50: rid of the equal sign here so I made
00:10:48 - 00:10:52: this no longer optional then I get an
00:10:50 - 00:10:54: error and it says it's missing one
00:10:52 - 00:10:57: required positional argument okay that's
00:10:54 - 00:10:58: worth noting now if I try to access Zed
00:10:57 - 00:11:00: here you'll see that actually let's make
00:10:58 - 00:11:03: it equal something like 10.
00:11:00 - 00:11:04: if I run this it actually gets its
00:11:03 - 00:11:06: default value so when you make something
00:11:04 - 00:11:08: optional really what you're doing is
00:11:06 - 00:11:10: providing a default value for it which
00:11:08 - 00:11:12: means if you don't pass that value when
00:11:10 - 00:11:14: you call the function by default it will
00:11:12 - 00:11:16: be equal to that value okay so that was
00:11:14 - 00:11:18: actually the easy stuff now we move on
00:11:16 - 00:11:21: to the more complicated ones now we have
00:11:18 - 00:11:23: something referred to as asterisk arcs
00:11:21 - 00:11:25: now what this allows us to do is
00:11:23 - 00:11:28: actually accept any number of positional
00:11:25 - 00:11:31: arguments so I can pass
00:11:28 - 00:11:34: a bunch of arguments like this
00:11:31 - 00:11:36: okay I can pass no additional arguments
00:11:34 - 00:11:38: I can pass one two whatever it's any
00:11:36 - 00:11:42: number after my positional arguments so
00:11:38 - 00:11:44: if I print out x y z and then args here
00:11:42 - 00:11:45: and I run the code you see that this is
00:11:44 - 00:11:48: perfectly valid so when I do this
00:11:45 - 00:11:49: asterisk args again this means okay I'm
00:11:48 - 00:11:53: going to accept any number of positional
00:11:49 - 00:11:54: arguments at this point so after my two
00:11:53 - 00:11:56: positional arguments that I have here
00:11:54 - 00:11:59: and it's going to store all of them in a
00:11:56 - 00:12:02: tuple which is an e-mutable type okay if
00:11:59 - 00:12:04: we just have star args here then you see
00:12:02 - 00:12:06: it works the exact same way we accept
00:12:04 - 00:12:09: any number of positional arguments even
00:12:06 - 00:12:11: zero right so if I have none here this
00:12:09 - 00:12:13: works perfectly fine okay that is star
00:12:11 - 00:12:16: args now we also have
00:12:13 - 00:12:18: star star quarks so when you have star
00:12:16 - 00:12:20: star quarks this means we're going to
00:12:18 - 00:12:23: accept any number of keyword arguments
00:12:20 - 00:12:25: so let me just print out quarks here and
00:12:23 - 00:12:26: go and pass some keyword arguments so
00:12:25 - 00:12:28: the keyword arguments are like this
00:12:26 - 00:12:31: something like x equals one
00:12:28 - 00:12:32: s is equal to
00:12:31 - 00:12:36: I don't know hello
00:12:32 - 00:12:38: B is equal to True whatever let's do a
00:12:36 - 00:12:40: capital true here so now if I run this
00:12:38 - 00:12:41: you see that we have no positional
00:12:40 - 00:12:43: arguments but we have these three
00:12:41 - 00:12:45: keyword arguments and they are stored
00:12:43 - 00:12:47: inside of a dictionary so if I want to
00:12:45 - 00:12:49: access any of these individual keyword
00:12:47 - 00:12:51: arguments I go quarks and then I
00:12:49 - 00:12:54: reference whatever the key is so I want
00:12:51 - 00:12:56: to reference X here and notice I get one
00:12:54 - 00:12:57: okay this is useful when you want to
00:12:56 - 00:12:59: make your functions Dynamic and you
00:12:57 - 00:13:00: don't know how many regular arguments or
00:12:59 - 00:13:02: keyword arguments are going to be
00:13:00 - 00:13:04: accepting now you can obviously pass
00:13:02 - 00:13:06: both so if I do something like one two
00:13:04 - 00:13:08: three and then some keyword arguments
00:13:06 - 00:13:10: here you'll now see that we'll get both
00:13:08 - 00:13:12: args and quarks having some values and
00:13:10 - 00:13:15: then we can process those values however
00:13:12 - 00:13:17: we see fit okay great last thing to show
00:13:15 - 00:13:20: you is how to use these uh with inside
00:13:17 - 00:13:21: of your function so let's swap this
00:13:20 - 00:13:25: around out and let's say we have like a
00:13:21 - 00:13:27: b and then C is equal to True d
00:13:25 - 00:13:30: is equal to false
00:13:27 - 00:13:33: okay now if we go here we can actually
00:13:30 - 00:13:35: use the asterisks to kind of break apart
00:13:33 - 00:13:38: a list and pass different positional
00:13:35 - 00:13:39: arguments so let's have a list here and
00:13:38 - 00:13:41: I have one two three inside of it and
00:13:39 - 00:13:44: these are actually the corresponding
00:13:41 - 00:13:46: values for both a b and not C Just A and
00:13:44 - 00:13:48: B if that's the case I can't just pass
00:13:46 - 00:13:49: this list because if I do that it's
00:13:48 - 00:13:52: going to be the positional argument for
00:13:49 - 00:13:53: a so what I can do is put an asterisk
00:13:52 - 00:13:55: before it and this is actually going to
00:13:53 - 00:13:58: kind of decompose or break this apart
00:13:55 - 00:14:01: into two individual positional arguments
00:13:58 - 00:14:04: so if I go here and I print my a and my
00:14:01 - 00:14:07: B and I run this notice I get 1 2 works
00:14:04 - 00:14:09: perfectly fine okay now we have the same
00:14:07 - 00:14:11: thing we can do with our keyword
00:14:09 - 00:14:12: arguments so let's say I have a
00:14:11 - 00:14:15: dictionary that contains my keyword
00:14:12 - 00:14:19: arguments something like C is I don't
00:14:15 - 00:14:22: know hello and D is cool I can actually
00:14:19 - 00:14:23: place a dictionary here and then put two
00:14:22 - 00:14:25: asterisks before it and what this will
00:14:23 - 00:14:27: do is break this dictionary into its
00:14:25 - 00:14:31: keyword arguments and pass that to the
00:14:27 - 00:14:33: file function so now I can print C and D
00:14:31 - 00:14:35: and when I have a look uh what does it
00:14:33 - 00:14:37: say here C is not defined sorry we need
00:14:35 - 00:14:39: to just add a string here
00:14:37 - 00:14:41: always forget that you need to do that
00:14:39 - 00:14:43: in Python let's clear and rerun and
00:14:41 - 00:14:45: notice now that we get the values for
00:14:43 - 00:14:47: our keyword arguments so the next
00:14:45 - 00:14:49: concept here is if underscore underscore
00:14:47 - 00:14:52: name equals underscore underscore main
00:14:49 - 00:14:54: now this is simply telling you if you
00:14:52 - 00:14:56: ran the current python file the reason
00:14:54 - 00:14:58: why it's important to understand that is
00:14:56 - 00:14:59: because a lot of times you can have a
00:14:58 - 00:15:01: bunch of different python modules and
00:14:59 - 00:15:04: sometimes you run the module directly
00:15:01 - 00:15:05: other times it might be imported by a
00:15:04 - 00:15:07: different module so let's have a look at
00:15:05 - 00:15:09: this example in this case we have
00:15:07 - 00:15:11: start.pi we have some function
00:15:09 - 00:15:12: and then we have this if underscore
00:15:11 - 00:15:14: under square name equals equals
00:15:12 - 00:15:16: underscore underscore main we're
00:15:14 - 00:15:19: printing run then we have another file
00:15:16 - 00:15:22: here inside of this file we import the
00:15:19 - 00:15:24: add function from this start module now
00:15:22 - 00:15:26: if I didn't have this line here what
00:15:24 - 00:15:29: would happen is when I import this
00:15:26 - 00:15:31: module by default python would read the
00:15:29 - 00:15:32: entire kind of block of code here the
00:15:31 - 00:15:34: entire file and if I didn't have
00:15:32 - 00:15:36: something inside of the if statement so
00:15:34 - 00:15:37: I just had to say print run here then it
00:15:36 - 00:15:40: would actually execute that line of code
00:15:37 - 00:15:42: which I might not want to happen unless
00:15:40 - 00:15:44: I'm actually inside of that module or
00:15:42 - 00:15:46: sorry not inside of that module but if I
00:15:44 - 00:15:48: ran that module it's better if I just
00:15:46 - 00:15:50: show it to you so if I go here and I run
00:15:48 - 00:15:53: pythonstart.pi you see that we get run
00:15:50 - 00:15:55: printing out to the screen however if I
00:15:53 - 00:15:58: run my other file so python other
00:15:55 - 00:16:01: file.pi notice it doesn't print out run
00:15:58 - 00:16:03: however if I remove this line here and
00:16:01 - 00:16:06: we remove the indentation now it will
00:16:03 - 00:16:08: print run so the purpose again of having
00:16:06 - 00:16:10: this line is to determine if you ran
00:16:08 - 00:16:12: this file drag directly a lot of times
00:16:10 - 00:16:13: you have a file where it has a ton of
00:16:12 - 00:16:15: utility functions that are going to be
00:16:13 - 00:16:17: imported by other files and then you
00:16:15 - 00:16:18: have something you might want to do when
00:16:17 - 00:16:20: you're running it directly like maybe
00:16:18 - 00:16:22: initializing a game or starting some
00:16:20 - 00:16:24: program or sending an API request
00:16:22 - 00:16:26: whatever it may be but you don't want
00:16:24 - 00:16:29: this event to occur you don't want this
00:16:26 - 00:16:31: code to run if it's being imported only
00:16:29 - 00:16:32: if it's being ran directly so that's how
00:16:31 - 00:16:35: you use this that's pretty much all you
00:16:32 - 00:16:36: need to know hopefully now you know so
00:16:35 - 00:16:38: the next concept to go over here does
00:16:36 - 00:16:41: not involve my computer and this is the
00:16:38 - 00:16:43: Gil or the global interpreter lock now
00:16:41 - 00:16:45: this is exclusive to Python and
00:16:43 - 00:16:47: essentially what this says is that any
00:16:45 - 00:16:50: thread that wants to be executing needs
00:16:47 - 00:16:52: to acquire The Interpreter lock now what
00:16:50 - 00:16:54: that kind of technically means for you
00:16:52 - 00:16:56: is that you can only execute one thread
00:16:54 - 00:16:59: at the same time even if you have
00:16:56 - 00:17:00: multiple CPU cores on your computer now
00:16:59 - 00:17:02: to better illustrate this because I'm
00:17:00 - 00:17:04: sure it's a bit confusing on your
00:17:02 - 00:17:06: computer you have a CPU or in your
00:17:04 - 00:17:08: computer you have a CPU that CPU will
00:17:06 - 00:17:11: typically have multiple cores two cores
00:17:08 - 00:17:13: four core eight cores whatever it may be
00:17:11 - 00:17:16: now each one of these cores can execute
00:17:13 - 00:17:18: one operation at a time with hyper
00:17:16 - 00:17:19: threading and virtualization you might
00:17:18 - 00:17:21: be able to do a few more I'm not going
00:17:19 - 00:17:23: to talk about all the details there for
00:17:21 - 00:17:26: Simplicity let's say each CPU core can
00:17:23 - 00:17:27: execute one operation well this is great
00:17:26 - 00:17:29: because that means your CPU can be
00:17:27 - 00:17:31: working on multiple things at the same
00:17:29 - 00:17:33: time and if you have a complex
00:17:31 - 00:17:34: application it's possible that you want
00:17:33 - 00:17:36: to be doing something like processing an
00:17:34 - 00:17:38: image while allowing a user to type
00:17:36 - 00:17:40: something in while maybe sending a
00:17:38 - 00:17:42: request to the network there's a ton of
00:17:40 - 00:17:43: different things you could be doing at
00:17:42 - 00:17:46: the same time and this is where
00:17:43 - 00:17:47: multi-threading comes in a thread is
00:17:46 - 00:17:49: essentially a component of your
00:17:47 - 00:17:51: application that's being executed by the
00:17:49 - 00:17:53: CPU when you start getting into larger
00:17:51 - 00:17:55: programs you start designing
00:17:53 - 00:17:57: multi-threaded applications where you
00:17:55 - 00:17:59: have different pieces of your code
00:17:57 - 00:18:01: separated into different threads such
00:17:59 - 00:18:03: that they can execute at the same point
00:18:01 - 00:18:05: in time now with python you can do this
00:18:03 - 00:18:07: you can have multiple threads the issue
00:18:05 - 00:18:09: becomes though that you have this Global
00:18:07 - 00:18:11: interpreter lock now what that means is
00:18:09 - 00:18:13: even if you have a bunch of CPU cores on
00:18:11 - 00:18:16: your computer only one of these threads
00:18:13 - 00:18:18: can be executing at a time that's
00:18:16 - 00:18:20: because this thread needs to acquire
00:18:18 - 00:18:22: something known as a lock on The
00:18:20 - 00:18:24: Interpreter now I'm not going to discuss
00:18:22 - 00:18:26: why this was implemented in Python but
00:18:24 - 00:18:28: what you need to know about this is that
00:18:26 - 00:18:29: if you do actually have multiple threads
00:18:28 - 00:18:31: this is not going to give you a
00:18:29 - 00:18:33: performance bonus in Python it's not
00:18:31 - 00:18:35: going to increase the speed at which you
00:18:33 - 00:18:36: execute your code so to give you a
00:18:35 - 00:18:39: simple example here let's say I wanted
00:18:36 - 00:18:41: to sum the numbers from 1 to 100. well
00:18:39 - 00:18:42: if I was doing this in a single thread
00:18:41 - 00:18:45: I'd have to sum all of the numbers from
00:18:42 - 00:18:47: 1 to 100 in a row however what could be
00:18:45 - 00:18:49: more efficient is if I split this into
00:18:47 - 00:18:51: four threads or six threads or eight
00:18:49 - 00:18:53: threads and I summed sections of the
00:18:51 - 00:18:57: numbers for example if there was four of
00:18:53 - 00:19:00: me then I could sum the first 0 to 25 25
00:18:57 - 00:19:02: to 50 50 to 75 75 to 100 and then I
00:19:00 - 00:19:03: could add all of those values together
00:19:02 - 00:19:06: and this would allow me to sum the
00:19:03 - 00:19:07: numbers four times faster and in a
00:19:06 - 00:19:09: traditional programming language you can
00:19:07 - 00:19:10: do this you can create four threads
00:19:09 - 00:19:12: they're going to be executed on four
00:19:10 - 00:19:14: different CPU cores and this will allow
00:19:12 - 00:19:17: you to very quickly speed up your
00:19:14 - 00:19:19: programs using these multiple threats in
00:19:17 - 00:19:21: Python you can't do that even though you
00:19:19 - 00:19:23: have these multiple threads only one of
00:19:21 - 00:19:25: them can execute at a time which means
00:19:23 - 00:19:26: it doesn't matter how you split these
00:19:25 - 00:19:28: things up it's going to take the exact
00:19:26 - 00:19:30: same amount of time or approximately the
00:19:28 - 00:19:32: exact same amount of time to execute
00:19:30 - 00:19:34: this code now I'm going to stop here
00:19:32 - 00:19:36: hopefully you get the point that you can
00:19:34 - 00:19:37: only have one thread in execution at a
00:19:36 - 00:19:39: time if you know that you pretty much
00:19:37 - 00:19:41: know the global interpreter lock if you
00:19:39 - 00:19:42: want to learn more then I'll encourage
00:19:41 - 00:19:44: you to read about it or let me know in
00:19:42 - 00:19:46: the comments if you want to see me make
00:19:44 - 00:19:48: an entire video on it regardless I'm
00:19:46 - 00:19:49: going to wrap it up here I hope that you
00:19:48 - 00:19:53: found this helpful and I look forward to
00:19:49 - 00:19:53: seeing you in another YouTube video
00:19:54 - 00:20:01: foreign
00:19:56 - 00:20:01: [Music]
