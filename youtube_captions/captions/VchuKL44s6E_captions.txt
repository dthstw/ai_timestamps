00:00:00 - 00:00:04: hello everybody and welcome to python as
00:00:03 - 00:00:06: fast as possible
00:00:04 - 00:00:08: in this video i'm going to be trying to
00:00:06 - 00:00:09: teach you python as quickly as i
00:00:08 - 00:00:11: possibly can
00:00:09 - 00:00:13: that means i am going to go over things
00:00:11 - 00:00:13: quite quickly i'm going to talk very
00:00:13 - 00:00:15: fast
00:00:13 - 00:00:17: and i will note that this is not for
00:00:15 - 00:00:19: absolute beginners if you are looking
00:00:17 - 00:00:20: for a beginner level tutorial series i
00:00:19 - 00:00:22: have many on my channel
00:00:20 - 00:00:24: i will link a ton of resources down
00:00:22 - 00:00:26: below and if you feel that i missed
00:00:24 - 00:00:28: anything or made any mistakes please do
00:00:26 - 00:00:29: leave a comment with that being said
00:00:28 - 00:00:33: let's go ahead and get started and get
00:00:29 - 00:00:33: into python as fast as possible
00:00:34 - 00:00:38: [Music]
00:00:40 - 00:00:44: to get started we need to download and
00:00:42 - 00:00:46: install python please download the most
00:00:44 - 00:00:48: recent version of python from the python
00:00:46 - 00:00:48: website which will be linked in the
00:00:48 - 00:00:50: description
00:00:48 - 00:00:52: if you're using any version of python
00:00:50 - 00:00:54: which is below 3.6 that will not be
00:00:52 - 00:00:56: compatible with this tutorial
00:00:54 - 00:00:58: when downloading please check the box
00:00:56 - 00:01:00: that says add python
00:00:58 - 00:01:01: to path this will make your life easier
00:01:00 - 00:01:03: in the future now python
00:01:01 - 00:01:05: automatically comes with its own
00:01:03 - 00:01:05: environment to write code in this is
00:01:05 - 00:01:07: idle
00:01:05 - 00:01:09: you can use this to write your code if
00:01:07 - 00:01:11: you'd like but i prefer to use visual
00:01:09 - 00:01:12: studio code which is a text editor
00:01:11 - 00:01:14: to download that you can go to the link
00:01:12 - 00:01:15: in the description and just download the
00:01:14 - 00:01:16: stable build for whatever operating
00:01:15 - 00:01:18: system you're on
00:01:16 - 00:01:20: now if you're using vs code there is one
00:01:18 - 00:01:21: little bit of setup we need to do to get
00:01:20 - 00:01:22: started here
00:01:21 - 00:01:25: we simply need to install the python
00:01:22 - 00:01:26: extension go to the extension tab here
00:01:25 - 00:01:27: this will bring us to the vs code
00:01:26 - 00:01:29: marketplace
00:01:27 - 00:01:31: we can type python and then we can see
00:01:29 - 00:01:33: the python extension and simply press
00:01:31 - 00:01:35: install you can see for myself i already
00:01:33 - 00:01:36: have it installed
00:01:35 - 00:01:38: so before we get started i thought it
00:01:36 - 00:01:39: would be a good idea to talk to you
00:01:38 - 00:01:40: about some of the things that python is
00:01:39 - 00:01:42: used for
00:01:40 - 00:01:43: here i am on my channel in the playlist
00:01:42 - 00:01:45: tab and you can see a bunch of different
00:01:43 - 00:01:46: playlists just giving you an idea
00:01:45 - 00:01:49: of some of the things that i've created
00:01:46 - 00:01:51: with python and taught on this channel
00:01:49 - 00:01:53: python is a general purpose programming
00:01:51 - 00:01:56: language it is very easy to learn
00:01:53 - 00:01:57: versatile and really easy to write in
00:01:56 - 00:01:59: the core advantage of python is
00:01:57 - 00:02:01: typically how simple it is
00:01:59 - 00:02:02: how easy the syntax is to read and just
00:02:01 - 00:02:05: how fast development is
00:02:02 - 00:02:07: with it that being said python is mostly
00:02:05 - 00:02:08: used on the web and in machine learning
00:02:07 - 00:02:10: artificial
00:02:08 - 00:02:12: intelligence and data science related
00:02:10 - 00:02:14: tasks now the sponsor of our video knows
00:02:12 - 00:02:16: a ton about that and that is
00:02:14 - 00:02:18: simply life i need to thank simply learn
00:02:16 - 00:02:19: for sponsoring this video and giving you
00:02:18 - 00:02:21: all a discount on their data scientist
00:02:19 - 00:02:22: master program that was co-developed
00:02:21 - 00:02:24: with ibm
00:02:22 - 00:02:26: this program is comprised of six unique
00:02:24 - 00:02:28: courses that implement a unique
00:02:26 - 00:02:30: blended learning experience in a high
00:02:28 - 00:02:32: engagement online classroom environment
00:02:30 - 00:02:34: during this program you will master 30
00:02:32 - 00:02:36: plus in-demand skills and work with
00:02:34 - 00:02:39: tools and languages like r sas
00:02:36 - 00:02:41: python tableau hadoop and spark you'll
00:02:39 - 00:02:42: master these skills through 15 real life
00:02:41 - 00:02:44: projects
00:02:42 - 00:02:45: and one capstone project during this 12
00:02:44 - 00:02:47: month
00:02:45 - 00:02:49: comprehensive course you'll also be
00:02:47 - 00:02:50: given 1200 usd worth of ibm cloud
00:02:49 - 00:02:52: credits
00:02:50 - 00:02:54: to use during your 24 7 access to the
00:02:52 - 00:02:55: ibm watson platform
00:02:54 - 00:02:57: after completion of this course you'll
00:02:55 - 00:02:59: be given certificates from ibm and
00:02:57 - 00:03:01: simply learn to testify to your skills
00:02:59 - 00:03:02: as an expert in data science
00:03:01 - 00:03:04: get started by hitting the link in the
00:03:02 - 00:03:07: description i want to start by covering
00:03:04 - 00:03:09: the core data types in python
00:03:07 - 00:03:10: these are int float string and bool and
00:03:09 - 00:03:13: otherwise known as
00:03:10 - 00:03:14: integer now an integer or int is simply
00:03:13 - 00:03:16: any whole number
00:03:14 - 00:03:17: that does not have a decimal point on it
00:03:16 - 00:03:19: so two three seven
00:03:17 - 00:03:21: three seven that was going to be an int
00:03:19 - 00:03:24: negative nine that's an inch negative
00:03:21 - 00:03:26: some random large number is an int so
00:03:24 - 00:03:27: long as it does not have a decimal point
00:03:26 - 00:03:29: on it
00:03:27 - 00:03:30: we consider it an int a float is almost
00:03:29 - 00:03:32: the opposite of that
00:03:30 - 00:03:35: it is simply any number that has a
00:03:32 - 00:03:37: decimal point on it so something like
00:03:35 - 00:03:39: 272.00 this is a float even though you
00:03:37 - 00:03:41: can would consider this a whole number
00:03:39 - 00:03:43: the point zero adds a level of precision
00:03:41 - 00:03:45: to this which makes it a float
00:03:43 - 00:03:47: of course something like 9.7 would be a
00:03:45 - 00:03:50: float whenever you see a decimal point
00:03:47 - 00:03:52: that means the number is a float
00:03:50 - 00:03:54: next we have string a string is simply
00:03:52 - 00:03:55: anything surrounded by single or double
00:03:54 - 00:03:57: quotation marks
00:03:55 - 00:03:59: typically we consider this a sequence of
00:03:57 - 00:04:00: characters or
00:03:59 - 00:04:03: numbers so if i type something like
00:04:00 - 00:04:04: hello and i type something like hello
00:04:03 - 00:04:06: these two strings are actually
00:04:04 - 00:04:08: completely equivalent it does not matter
00:04:06 - 00:04:10: whether you use single or
00:04:08 - 00:04:12: double quotation marks there is no
00:04:10 - 00:04:12: difference i will note that if you want
00:04:12 - 00:04:14: to embed
00:04:12 - 00:04:16: a double quotation mark or a single
00:04:14 - 00:04:16: quotation mark in the actual string
00:04:16 - 00:04:18: itself
00:04:16 - 00:04:20: then you would usually wrap the string
00:04:18 - 00:04:21: with the opposite type of quotation mark
00:04:20 - 00:04:23: so in this case i want to have this
00:04:21 - 00:04:25: double quotation mark inside the string
00:04:23 - 00:04:27: so i wrap the string with single
00:04:25 - 00:04:29: quotation marks now just to note here if
00:04:27 - 00:04:30: i do something like 4.6
00:04:29 - 00:04:32: even though you might consider this a
00:04:30 - 00:04:34: float this is a string
00:04:32 - 00:04:35: again because it is surrounded by single
00:04:34 - 00:04:38: or double quotation marks
00:04:35 - 00:04:40: remember the definition anything defined
00:04:38 - 00:04:41: or surrounded sorry by single or double
00:04:40 - 00:04:43: quotation marks
00:04:41 - 00:04:44: next we have boolean this is one of two
00:04:43 - 00:04:47: values
00:04:44 - 00:04:48: we have true or we have false some
00:04:47 - 00:04:50: people may consider this one and
00:04:48 - 00:04:51: consider this zero we're going to look
00:04:50 - 00:04:52: at these later on and you'll see why
00:04:51 - 00:04:54: that's important
00:04:52 - 00:04:57: but that is a boolean value and these
00:04:54 - 00:04:58: are the four core data types in python
00:04:57 - 00:05:00: the next topic i'd like to cover is
00:04:58 - 00:05:02: output and printing this is very
00:05:00 - 00:05:03: important and we will be doing this a
00:05:02 - 00:05:05: lot in this video
00:05:03 - 00:05:07: in python there is a simple function
00:05:05 - 00:05:08: called print this is how you output
00:05:07 - 00:05:09: something to the console when you run
00:05:08 - 00:05:11: your program
00:05:09 - 00:05:12: typically when you print something
00:05:11 - 00:05:14: you'll put it in strings so i want to
00:05:12 - 00:05:15: print say hello world
00:05:14 - 00:05:17: so i will print the string hello world
00:05:15 - 00:05:19: like that and if i run my program by
00:05:17 - 00:05:20: pressing this run button
00:05:19 - 00:05:22: you can see down here in the console we
00:05:20 - 00:05:24: get hello world now notice that if i
00:05:22 - 00:05:26: just type hello world like this and i
00:05:24 - 00:05:28: don't put it inside of a string
00:05:26 - 00:05:30: and i run my program i will get an error
00:05:28 - 00:05:32: this is because i cannot simply print
00:05:30 - 00:05:34: something like this the program does not
00:05:32 - 00:05:36: know how to interpret hello world
00:05:34 - 00:05:38: if it is not wrapped in strings that is
00:05:36 - 00:05:40: because this is not one of the core data
00:05:38 - 00:05:42: types and we have no variable or
00:05:40 - 00:05:44: anything that denotes what hello world
00:05:42 - 00:05:46: is that being said if i want to print a
00:05:44 - 00:05:48: number say like 4.5
00:05:46 - 00:05:50: python knows what 4.5 is because it is a
00:05:48 - 00:05:51: float you can see when i highlight it it
00:05:50 - 00:05:54: says float
00:05:51 - 00:05:54: if i run this it will print 4.5 out and
00:05:54 - 00:05:57: there will be
00:05:54 - 00:05:58: no problems now if you want to print
00:05:57 - 00:06:00: multiple things what you can do is
00:05:58 - 00:06:02: separate them by commas
00:06:00 - 00:06:03: so say i'd like to print 4.5 and then i
00:06:02 - 00:06:05: would like to print hello
00:06:03 - 00:06:07: when i do this it will automatically add
00:06:05 - 00:06:08: a space between the two things
00:06:07 - 00:06:11: let's just put another string here just
00:06:08 - 00:06:14: to show you what i mean so 4.5 hello
00:06:11 - 00:06:15: notice it adds that space in between now
00:06:14 - 00:06:17: we will talk about how you can print
00:06:15 - 00:06:19: things without the space in between
00:06:17 - 00:06:21: later on but that is the basics of a
00:06:19 - 00:06:23: print if i want to print many things on
00:06:21 - 00:06:26: the same line i can go hello
00:06:23 - 00:06:30: i could say end i can say 87
00:06:26 - 00:06:32: i can say false and i can run this
00:06:30 - 00:06:34: and this will all work hello and 87
00:06:32 - 00:06:35: false now there's a few arguments that
00:06:34 - 00:06:37: you can pass
00:06:35 - 00:06:38: into the print function if you do a
00:06:37 - 00:06:40: comma and then type
00:06:38 - 00:06:42: end equals you can denote what you want
00:06:40 - 00:06:44: the end of this print statement to be
00:06:42 - 00:06:46: by default the end here is a carriage
00:06:44 - 00:06:49: return which is backslash n
00:06:46 - 00:06:51: what that means is go to the next line
00:06:49 - 00:06:52: after this line is printed
00:06:51 - 00:06:54: now notice if i don't add this backslash
00:06:52 - 00:06:54: enter in fact let me just show you what
00:06:54 - 00:06:57: happens
00:06:54 - 00:06:58: by default so let's say i have hello and
00:06:57 - 00:07:00: 87
00:06:58 - 00:07:02: i'm going to get rid of this and i print
00:07:00 - 00:07:02: both these things out we get these on
00:07:02 - 00:07:04: two
00:07:02 - 00:07:05: separate lines that is the default
00:07:04 - 00:07:07: behavior of the print statement and
00:07:05 - 00:07:10: prints on a new line
00:07:07 - 00:07:12: now notice if i add end e end equals
00:07:10 - 00:07:15: and instead of a backslash n let's say
00:07:12 - 00:07:17: uh this pipe like that and i run this
00:07:15 - 00:07:18: now at the end of the print statement it
00:07:17 - 00:07:20: simply prints a pipe
00:07:18 - 00:07:21: it does not add the carriage return
00:07:20 - 00:07:22: which means we do not move on to the
00:07:21 - 00:07:23: next line
00:07:22 - 00:07:24: that's a little bit more advanced but
00:07:23 - 00:07:25: essentially the carriage return is that
00:07:24 - 00:07:27: backslash n
00:07:25 - 00:07:28: and again that means just move down to
00:07:27 - 00:07:30: the next line
00:07:28 - 00:07:33: that is the basics of printing and
00:07:30 - 00:07:35: output and now let's move on
00:07:33 - 00:07:36: next let's move on to variables
00:07:35 - 00:07:37: variables are an important part of any
00:07:36 - 00:07:40: program
00:07:37 - 00:07:42: in python they are quite easy to create
00:07:40 - 00:07:44: when you create a variable in python
00:07:42 - 00:07:45: you simply type a variable name a space
00:07:44 - 00:07:47: an equal sign
00:07:45 - 00:07:49: and then assign it to some value this
00:07:47 - 00:07:51: value is going to be some
00:07:49 - 00:07:52: data type some function something else
00:07:51 - 00:07:54: that we'll talk about
00:07:52 - 00:07:56: later on to give you a basic example i'm
00:07:54 - 00:07:58: going to set the variable hello equal to
00:07:56 - 00:08:00: the value 10.
00:07:58 - 00:08:02: think of a variable like a bucket that
00:08:00 - 00:08:05: stores some data or stores some type
00:08:02 - 00:08:06: now if i want to access the value that
00:08:05 - 00:08:08: is stored in hello
00:08:06 - 00:08:09: what i can do is i can simply say print
00:08:08 - 00:08:11: hello
00:08:09 - 00:08:12: what this will do is it will say okay
00:08:11 - 00:08:14: this is a variable
00:08:12 - 00:08:15: i know it's a variable because i saw it
00:08:14 - 00:08:18: earlier on the program
00:08:15 - 00:08:19: let me see what its value is and i will
00:08:18 - 00:08:21: print that value
00:08:19 - 00:08:23: so now i'm going to run and you can see
00:08:21 - 00:08:24: that we get tim
00:08:23 - 00:08:26: let's make another variable let's call
00:08:24 - 00:08:28: this world let's actually set this equal
00:08:26 - 00:08:30: to the value world
00:08:28 - 00:08:31: now let's print hello comma world and
00:08:30 - 00:08:34: let's see what we get
00:08:31 - 00:08:36: we get tim and then space world
00:08:34 - 00:08:37: variables are somewhat complex
00:08:36 - 00:08:39: you can make them equal to other
00:08:37 - 00:08:40: variables if i decide to change the
00:08:39 - 00:08:42: value
00:08:40 - 00:08:44: of world to actually be equal to the
00:08:42 - 00:08:45: variable hello what's going to happen is
00:08:44 - 00:08:46: it's going to say okay hello is a
00:08:45 - 00:08:48: variable
00:08:46 - 00:08:50: what is a low equal to hello is equal to
00:08:48 - 00:08:52: tim so i will print
00:08:50 - 00:08:53: tim now watch what we're going to get we
00:08:52 - 00:08:55: get tim tim
00:08:53 - 00:08:57: now what happens if i come here and i
00:08:55 - 00:09:00: change hello to be equal to
00:08:57 - 00:09:02: no if i do this what's going to happen
00:09:00 - 00:09:04: is world will not change because world
00:09:02 - 00:09:07: was set equal to the value of hello
00:09:04 - 00:09:07: at this line at this point in time line
00:09:07 - 00:09:09: three
00:09:07 - 00:09:10: because our program reads from top to
00:09:09 - 00:09:14: bottom
00:09:10 - 00:09:15: the value of hello was tim so world gets
00:09:14 - 00:09:17: set to tim
00:09:15 - 00:09:18: then hello gets set to no that does not
00:09:17 - 00:09:20: change the value of world so what you're
00:09:18 - 00:09:22: going to see is we're going to have
00:09:20 - 00:09:24: tim and then we're going to have no so
00:09:22 - 00:09:25: let's have a look here and sorry other
00:09:24 - 00:09:27: way around we get no
00:09:25 - 00:09:29: tim my bad though we printed a hello
00:09:27 - 00:09:29: first and then world i have that mixed
00:09:29 - 00:09:31: up
00:09:29 - 00:09:32: that is the basics of variables there's
00:09:31 - 00:09:33: many other things that we can do with
00:09:32 - 00:09:34: them
00:09:33 - 00:09:36: but let me just tell you about the
00:09:34 - 00:09:37: naming conventions for them
00:09:36 - 00:09:39: so in a variable you are not allowed to
00:09:37 - 00:09:41: have any special characters and you
00:09:39 - 00:09:42: cannot start with a number
00:09:41 - 00:09:44: so you are allowed to have an underscore
00:09:42 - 00:09:45: that is the only exception in terms of
00:09:44 - 00:09:47: special characters
00:09:45 - 00:09:49: usually you will use that when you are
00:09:47 - 00:09:50: denoting a space and in python the
00:09:49 - 00:09:52: convention is typically to separate
00:09:50 - 00:09:53: things using an underscore
00:09:52 - 00:09:55: in other languages you may see something
00:09:53 - 00:09:56: like hello world if you wanted to make a
00:09:55 - 00:09:58: variable
00:09:56 - 00:10:00: uh that has multiple words in it but in
00:09:58 - 00:10:02: python stick with snake case which is
00:10:00 - 00:10:04: what this is known as the other one is
00:10:02 - 00:10:06: camelcase and use underscores to
00:10:04 - 00:10:07: separate your variables just to give you
00:10:06 - 00:10:09: an example of what i mean you cannot
00:10:07 - 00:10:11: start a variable with a number so
00:10:09 - 00:10:12: 9 hello notice i'm getting the red line
00:10:11 - 00:10:14: popping up here
00:10:12 - 00:10:15: and i could not do something like hello
00:10:14 - 00:10:18: 9 that does not work but
00:10:15 - 00:10:19: if i want to hello world 32 that is
00:10:18 - 00:10:21: totally fine that is a valid
00:10:19 - 00:10:23: variable name the next topic i want to
00:10:21 - 00:10:25: talk about is getting user input just
00:10:23 - 00:10:26: like printing something is very simple
00:10:25 - 00:10:28: getting input is simple as well
00:10:26 - 00:10:30: what we do is we simply use the input
00:10:28 - 00:10:31: function we have our open and close
00:10:30 - 00:10:32: parentheses and then we type what's
00:10:31 - 00:10:35: known as a prompt
00:10:32 - 00:10:36: inside of these brackets like this now
00:10:35 - 00:10:38: this does need to be in a string
00:10:36 - 00:10:40: unlike the print statement we cannot do
00:10:38 - 00:10:41: something like 4.5 in here that will not
00:10:40 - 00:10:43: work
00:10:41 - 00:10:44: we do need a string so what i'm going to
00:10:43 - 00:10:45: do is i'm going to add a prompt
00:10:44 - 00:10:48: say i want the user to type their name
00:10:45 - 00:10:50: then i will say name i'll do a colon and
00:10:48 - 00:10:51: then i will add a space between the
00:10:50 - 00:10:53: colon and the end of the string
00:10:51 - 00:10:55: the reason for this is that the user
00:10:53 - 00:10:57: will be able to start typing
00:10:55 - 00:10:58: on this line right after the prompt so
00:10:57 - 00:10:59: if i don't have a space then what's
00:10:58 - 00:11:00: going to happen is the user will start
00:10:59 - 00:11:02: typing
00:11:00 - 00:11:03: right where the colon is which of course
00:11:02 - 00:11:04: is not going to be good so let's go
00:11:03 - 00:11:06: ahead and run this and have a look at
00:11:04 - 00:11:08: what happens we can say name
00:11:06 - 00:11:10: colon space and now i'm going to type
00:11:08 - 00:11:12: tim that's great but how do we actually
00:11:10 - 00:11:14: get the value how do we store what the
00:11:12 - 00:11:16: user typed in so we can use
00:11:14 - 00:11:17: it later well we need to assign this
00:11:16 - 00:11:18: input to a variable
00:11:17 - 00:11:21: so what i'm going to do is i'm going to
00:11:18 - 00:11:22: say name is equal to input
00:11:21 - 00:11:23: i just want to note because i forgot to
00:11:22 - 00:11:24: say this previously we could have
00:11:23 - 00:11:26: capitals in
00:11:24 - 00:11:28: our variable name if we want that would
00:11:26 - 00:11:29: be fine but i'm not going to do that
00:11:28 - 00:11:32: and now what will happen is whatever we
00:11:29 - 00:11:34: type in will be returned to us
00:11:32 - 00:11:36: in this statement as a string and it
00:11:34 - 00:11:38: will be assigned to this variable name
00:11:36 - 00:11:39: so if i go ahead and print the value of
00:11:38 - 00:11:40: name what's going to happen is whatever
00:11:39 - 00:11:42: we type in here
00:11:40 - 00:11:44: will be printed out so let's have a look
00:11:42 - 00:11:47: at this name let's type tim
00:11:44 - 00:11:47: and we see that tim is printed out below
00:11:47 - 00:11:49: there
00:11:47 - 00:11:50: now we of course can get multiple user
00:11:49 - 00:11:51: input so i can say something like age
00:11:50 - 00:11:54: equals
00:11:51 - 00:11:55: input age colon and now let's see what
00:11:54 - 00:11:58: happens
00:11:55 - 00:12:00: when i run this so we go name tim age
00:11:58 - 00:12:02: 20 and we could put print those out if
00:12:00 - 00:12:03: we want but i'm not going to
00:12:02 - 00:12:04: actually you know what let me show you
00:12:03 - 00:12:05: one example where i print them out let's
00:12:04 - 00:12:08: say
00:12:05 - 00:12:12: hello and then let's go comma name
00:12:08 - 00:12:15: and then you are comma
00:12:12 - 00:12:17: age years old so this is a way that we
00:12:15 - 00:12:18: can combine variables and strings so
00:12:17 - 00:12:20: that we print out a meaningful response
00:12:18 - 00:12:22: that says hello whatever the name is
00:12:20 - 00:12:23: you are whatever the age is years old so
00:12:22 - 00:12:26: in this case i'll say
00:12:23 - 00:12:28: name tim age let's go 12 and says hello
00:12:26 - 00:12:30: tim you are 12 years old
00:12:28 - 00:12:31: all right so that is it for input now
00:12:30 - 00:12:32: we're going to move on and talk about
00:12:31 - 00:12:35: how we can actually convert
00:12:32 - 00:12:38: say numeric input into a integer or
00:12:35 - 00:12:39: float because it default comes back as
00:12:38 - 00:12:42: a string all right so the next topic i
00:12:39 - 00:12:44: want to cover is arithmetic operators
00:12:42 - 00:12:45: these essentially are like plus minus
00:12:44 - 00:12:48: multiplication exponent how you perform
00:12:45 - 00:12:49: mathematical operations in python
00:12:48 - 00:12:51: now just something to keep in mind when
00:12:49 - 00:12:52: we're performing and using arithmetic
00:12:51 - 00:12:54: operators
00:12:52 - 00:12:56: we have to make sure that the data types
00:12:54 - 00:12:57: on the left and right hand side of these
00:12:56 - 00:12:59: operators otherwise known as the
00:12:57 - 00:13:00: operands are the same data type or are
00:12:59 - 00:13:02: both
00:13:00 - 00:13:04: numbers what i mean by this is if i have
00:13:02 - 00:13:07: something like hello and i try to add
00:13:04 - 00:13:09: 9 to it well that just does not make any
00:13:07 - 00:13:10: sense and we are going to get a
00:13:09 - 00:13:12: error and something's going to be wrong
00:13:10 - 00:13:14: with our program so just keep that in
00:13:12 - 00:13:16: mind i cannot do hello minus 9.
00:13:14 - 00:13:18: you cannot do hello divided by 9. you
00:13:16 - 00:13:19: actually can use the multiplication you
00:13:18 - 00:13:20: can take a guess at what that's going to
00:13:19 - 00:13:22: do
00:13:20 - 00:13:23: but i will show you that later alright
00:13:22 - 00:13:25: so let's go through the basic operators
00:13:23 - 00:13:25: the first one is the plus sign very
00:13:25 - 00:13:28: straightforward
00:13:25 - 00:13:29: we can add 9 plus 3 or in this case i
00:13:28 - 00:13:32: could add
00:13:29 - 00:13:33: x plus y so x is 9 y is 3. we can add
00:13:32 - 00:13:34: those two values together
00:13:33 - 00:13:36: ignore the squiggly when i save that
00:13:34 - 00:13:39: goes away now something to keep in mind
00:13:36 - 00:13:39: if i make this 3.5 this works totally
00:13:39 - 00:13:40: fine
00:13:39 - 00:13:42: even though these are different data
00:13:40 - 00:13:44: types since they are both numbers i can
00:13:42 - 00:13:45: add them together
00:13:44 - 00:13:47: of course i can do the subtraction let's
00:13:45 - 00:13:49: run that i can do the multiplication
00:13:47 - 00:13:52: which is an asterisk
00:13:49 - 00:13:54: and i can do the division
00:13:52 - 00:13:55: we do the division we get some crazy
00:13:54 - 00:13:57: number just keep in mind that the
00:13:55 - 00:13:59: maximum precision in python i believe is
00:13:57 - 00:14:00: 13 decimal points
00:13:59 - 00:14:01: there is ways to get beyond that but
00:14:00 - 00:14:03: that is kind of too advanced i'm not
00:14:01 - 00:14:05: going to cover that right here and when
00:14:03 - 00:14:06: you ever do division or you're dealing
00:14:05 - 00:14:08: with rounding and all of that
00:14:06 - 00:14:09: that's always a problem in computers so
00:14:08 - 00:14:11: just keep that in mind you're not going
00:14:09 - 00:14:13: to get the most precise answers with
00:14:11 - 00:14:15: division like this
00:14:13 - 00:14:16: if this is a non-terminating decimal
00:14:15 - 00:14:18: point
00:14:16 - 00:14:19: anyways hopefully that makes sense now i
00:14:18 - 00:14:19: just want to point something out if i
00:14:19 - 00:14:22: actually have
00:14:19 - 00:14:24: say 9 over 3 of course you know that
00:14:22 - 00:14:25: that answer is 3 and that is a whole
00:14:24 - 00:14:27: number right 3 is a whole number
00:14:25 - 00:14:29: but this is actually returning to us a
00:14:27 - 00:14:30: float not in int
00:14:29 - 00:14:32: even though neither of these data types
00:14:30 - 00:14:34: are afloat the reason for that
00:14:32 - 00:14:36: is because whenever we use the division
00:14:34 - 00:14:38: operator it returns a float
00:14:36 - 00:14:40: because it does not know if it's going
00:14:38 - 00:14:41: to need to represent a floating point or
00:14:40 - 00:14:42: it's going to have to represent some
00:14:41 - 00:14:44: level of precision
00:14:42 - 00:14:46: so just keep that in mind if for some
00:14:44 - 00:14:47: reason you don't want this to be a float
00:14:46 - 00:14:49: of course you can convert the result to
00:14:47 - 00:14:52: an int by just doing int
00:14:49 - 00:14:52: like that okay so those are some of the
00:14:52 - 00:14:54: basic
00:14:52 - 00:14:56: arithmetic operators next we have
00:14:54 - 00:14:57: exponent so that's two asterisks like
00:14:56 - 00:14:59: that
00:14:57 - 00:15:00: this will raise x to the power y so we
00:14:59 - 00:15:03: can see that
00:15:00 - 00:15:05: gives us 729 and then next we have floor
00:15:03 - 00:15:06: division so what i'm going to do here is
00:15:05 - 00:15:08: actually make this a 10
00:15:06 - 00:15:10: have a guess at what you think this is
00:15:08 - 00:15:12: going to give but this gives us 3.
00:15:10 - 00:15:13: the reason it gives us 3 is because this
00:15:12 - 00:15:15: will give us the integer result of
00:15:13 - 00:15:18: whatever the division is
00:15:15 - 00:15:18: imagine this was like 9.333 or whatever
00:15:18 - 00:15:20: it may be
00:15:18 - 00:15:22: it just simply removes all of the
00:15:20 - 00:15:24: decimal points and just gives or sorry
00:15:22 - 00:15:25: to be 3.333
00:15:24 - 00:15:27: removes all the decimal points and just
00:15:25 - 00:15:30: gives us whatever that integer result
00:15:27 - 00:15:32: is next is mod this is the percent sign
00:15:30 - 00:15:33: this returns to us the remainder after a
00:15:32 - 00:15:36: division
00:15:33 - 00:15:38: in this case 10 mod 3 is going to be
00:15:36 - 00:15:38: well the answer is 9 and then remainder
00:15:38 - 00:15:40: 1
00:15:38 - 00:15:41: right so that is why we get 1 from this
00:15:40 - 00:15:44: here
00:15:41 - 00:15:46: i think that's it for those operators
00:15:44 - 00:15:48: now i will simply show you how we can do
00:15:46 - 00:15:50: say order of operations so if we want to
00:15:48 - 00:15:51: order of operations we can use brackets
00:15:50 - 00:15:53: or if we want to
00:15:51 - 00:15:55: evaluate things in a specific order this
00:15:53 - 00:15:57: does follow the simple order of
00:15:55 - 00:15:58: operations which the acronym i know for
00:15:57 - 00:16:03: it is bed mass which is b
00:15:58 - 00:16:04: e d and i hate this autocomplete it's
00:16:03 - 00:16:08: making it very hard to do this
00:16:04 - 00:16:10: m a s okay so what this stands for
00:16:08 - 00:16:11: is brackets exponents division
00:16:10 - 00:16:13: multiplication
00:16:11 - 00:16:15: addition subtraction python does follow
00:16:13 - 00:16:16: those standard order of operations if
00:16:15 - 00:16:18: you just write an expression
00:16:16 - 00:16:19: but of course it's always easier to use
00:16:18 - 00:16:21: brackets and spread things out so i can
00:16:19 - 00:16:23: say something like x
00:16:21 - 00:16:24: mod y and then i can multiply that by
00:16:23 - 00:16:25: two
00:16:24 - 00:16:27: since i didn't say it the integer
00:16:25 - 00:16:29: division and mod operators are in the
00:16:27 - 00:16:31: lowest order of order of operations so
00:16:29 - 00:16:33: if you use mod that is going to be below
00:16:31 - 00:16:34: addition and subtraction
00:16:33 - 00:16:36: pretty sure that's correct but someone
00:16:34 - 00:16:36: can correct me from the in the comments
00:16:36 - 00:16:38: if i'm wrong about that
00:16:36 - 00:16:40: but anyways you get the point you can
00:16:38 - 00:16:42: use brackets and that is how you can
00:16:40 - 00:16:44: perform and do arithmetic in a certain
00:16:42 - 00:16:45: way all right next thing i need to cover
00:16:44 - 00:16:47: here
00:16:45 - 00:16:48: is simply just an example using input so
00:16:47 - 00:16:53: what i'm going to say is
00:16:48 - 00:16:55: num equals input and we'll just say
00:16:53 - 00:16:56: number colon like that and what i want
00:16:55 - 00:16:59: to do is simply print the result
00:16:56 - 00:17:00: of num minus five so i want to take
00:16:59 - 00:17:02: whatever number they type in and i want
00:17:00 - 00:17:04: to subtract five from it and print that
00:17:02 - 00:17:05: to the screen so let's try it num equals
00:17:04 - 00:17:06: five
00:17:05 - 00:17:08: notice that it says unsupported operand
00:17:06 - 00:17:11: types for minus are
00:17:08 - 00:17:12: four sorry yeah minus string and int so
00:17:11 - 00:17:14: what that's saying is that num
00:17:12 - 00:17:16: is a string even though it looks like an
00:17:14 - 00:17:18: into us i'll explain why in a second
00:17:16 - 00:17:20: and we cannot subtract the number 5 from
00:17:18 - 00:17:21: it that just doesn't make any sense the
00:17:20 - 00:17:22: program doesn't know what to do with
00:17:21 - 00:17:24: that
00:17:22 - 00:17:26: so think about this why is num a string
00:17:24 - 00:17:28: we typed in 5
00:17:26 - 00:17:29: this should be an int value from what we
00:17:28 - 00:17:32: understand about our data types
00:17:29 - 00:17:33: well this input automatically returns to
00:17:32 - 00:17:35: us whatever we type in
00:17:33 - 00:17:36: in a string so just imagine that
00:17:35 - 00:17:37: whatever we do here it's going to give
00:17:36 - 00:17:39: us a string
00:17:37 - 00:17:41: and that means that if we want this to
00:17:39 - 00:17:43: actually be a numer numeric value and be
00:17:41 - 00:17:44: able to perform arithmetic on it we need
00:17:43 - 00:17:45: to convert it to an int
00:17:44 - 00:17:47: so there is this fancy function called
00:17:45 - 00:17:49: ins in python
00:17:47 - 00:17:51: this will take some string assuming that
00:17:49 - 00:17:53: there is an int inside of that string
00:17:51 - 00:17:54: and it will convert it into its integer
00:17:53 - 00:17:55: representation
00:17:54 - 00:17:57: let's have a look now when i type a
00:17:55 - 00:17:58: number let's say 10 of course we get the
00:17:57 - 00:18:01: value 5
00:17:58 - 00:18:02: it took num which was 10 so the string
00:18:01 - 00:18:05: 10 you know i'll type it
00:18:02 - 00:18:06: out like here we have the string 10 and
00:18:05 - 00:18:08: it simply converted that to the actual
00:18:06 - 00:18:09: integer value 10. now you can imagine we
00:18:08 - 00:18:10: have other functions in python that do
00:18:09 - 00:18:12: this as well
00:18:10 - 00:18:14: we have say float that's going to take
00:18:12 - 00:18:16: whatever we have here and convert
00:18:14 - 00:18:18: it into a float now notice what happens
00:18:16 - 00:18:20: when i do this if i do float 10
00:18:18 - 00:18:22: we get 5.0 whenever you have at least
00:18:20 - 00:18:24: one float in your arithmetic it's going
00:18:22 - 00:18:26: to automatically return to you a float
00:18:24 - 00:18:28: it needs to keep the level of precision
00:18:26 - 00:18:29: that was in the original you know
00:18:28 - 00:18:31: operation or in the original value so
00:18:29 - 00:18:32: just that's something to keep in mind
00:18:31 - 00:18:34: whenever you're doing you know plus
00:18:32 - 00:18:36: minus multiplication if there is one
00:18:34 - 00:18:38: float as the operand so on the left or
00:18:36 - 00:18:40: right hand side of the operator
00:18:38 - 00:18:42: then you are going to get a float result
00:18:40 - 00:18:44: back all right that is all i wanted to
00:18:42 - 00:18:45: show for this now let's move on
00:18:44 - 00:18:47: so the next thing i want to cover is
00:18:45 - 00:18:49: something called string methods
00:18:47 - 00:18:50: before i do that though i need to define
00:18:49 - 00:18:51: what a method is
00:18:50 - 00:18:53: so let's create a variable let's make
00:18:51 - 00:18:55: this equal to hello and we can just say
00:18:53 - 00:18:57: hello equals the string hello
00:18:55 - 00:18:58: i want to show you this function called
00:18:57 - 00:18:59: type which will tell us the type of a
00:18:58 - 00:19:02: variable
00:18:59 - 00:19:03: so if i print the type of hello well you
00:19:02 - 00:19:05: can imagine what type this is going to
00:19:03 - 00:19:06: be it's simply its data type let's have
00:19:05 - 00:19:08: a look here we get
00:19:06 - 00:19:09: class string you can ignore the angle
00:19:08 - 00:19:11: brackets in the class if you're more
00:19:09 - 00:19:12: advanced you probably already know what
00:19:11 - 00:19:13: this means but essentially what this is
00:19:12 - 00:19:15: saying
00:19:13 - 00:19:16: is that this string or this variable
00:19:15 - 00:19:19: here hello is an
00:19:16 - 00:19:20: instance of the class string again big
00:19:19 - 00:19:21: words you don't have to know what those
00:19:20 - 00:19:23: mean but for anyone more advanced
00:19:21 - 00:19:25: hopefully that makes sense to you
00:19:23 - 00:19:27: all right so how do we use a method on a
00:19:25 - 00:19:29: string and what is a method
00:19:27 - 00:19:31: well a method simply is something with a
00:19:29 - 00:19:33: dot operator so we have dot
00:19:31 - 00:19:35: we have sum and name whatever the method
00:19:33 - 00:19:37: name is in this case it's going to be
00:19:35 - 00:19:38: upper and then we have an open and close
00:19:37 - 00:19:40: bracket or parentheses whatever you want
00:19:38 - 00:19:42: to call them now i just want to show you
00:19:40 - 00:19:44: what these methods do so if i say hello
00:19:42 - 00:19:46: dot upper this is a method that we can
00:19:44 - 00:19:48: call only on strings
00:19:46 - 00:19:50: so since this is a string i can use this
00:19:48 - 00:19:52: dot upper method
00:19:50 - 00:19:54: on it and imagine what this is going to
00:19:52 - 00:19:55: do what this actually does is it upper
00:19:54 - 00:19:57: cases or
00:19:55 - 00:19:58: puts the entire string in completely
00:19:57 - 00:20:00: uppercase so if i have a look now at
00:19:58 - 00:20:02: hello
00:20:00 - 00:20:04: and we print it out we can see we get
00:20:02 - 00:20:05: hello in all capitals
00:20:04 - 00:20:08: now i don't need to call it like this i
00:20:05 - 00:20:09: also can do hello
00:20:08 - 00:20:11: dot upper now the reason this is going
00:20:09 - 00:20:13: to give me the same thing is because
00:20:11 - 00:20:14: well this is storing the value of the
00:20:13 - 00:20:16: string which is hello
00:20:14 - 00:20:18: and then it was just making an uppercase
00:20:16 - 00:20:20: right here now what happens it says okay
00:20:18 - 00:20:22: well what is hello equal to oh well
00:20:20 - 00:20:23: hello is equal to the string hello
00:20:22 - 00:20:25: so you can think of it as a substitution
00:20:23 - 00:20:27: this string just goes where that is
00:20:25 - 00:20:29: makes it upper and then prints it out
00:20:27 - 00:20:30: there we go upper now let's have a look
00:20:29 - 00:20:32: at what dot
00:20:30 - 00:20:34: lower does you can probably imagine
00:20:32 - 00:20:36: already but it simply makes the entire
00:20:34 - 00:20:37: string lower case
00:20:36 - 00:20:38: these are useful when you're getting
00:20:37 - 00:20:40: user input and you want to validate and
00:20:38 - 00:20:40: check if it's equal to something which
00:20:40 - 00:20:42: we will do
00:20:40 - 00:20:44: later on so a few other methods we have
00:20:42 - 00:20:45: dot capitalize
00:20:44 - 00:20:47: you can imagine what this does it simply
00:20:45 - 00:20:49: capitalizes the first letter in the
00:20:47 - 00:20:50: string and then makes the rest of it so
00:20:49 - 00:20:52: it looks good right so i've had a
00:20:50 - 00:20:54: sentence and i said like hello
00:20:52 - 00:20:56: world like that let's have a look at
00:20:54 - 00:20:57: this it's going to give me hello world
00:20:56 - 00:21:00: properly and if i added
00:20:57 - 00:21:02: a capital w like that it removes that
00:21:00 - 00:21:03: and it just kind of formats it as if a
00:21:02 - 00:21:05: sentence would
00:21:03 - 00:21:07: next we have this method called count
00:21:05 - 00:21:10: what count does is it will count
00:21:07 - 00:21:11: a specific string within the string so
00:21:10 - 00:21:13: it looks for a substring in the string
00:21:11 - 00:21:14: and how many times that occurs
00:21:13 - 00:21:16: let's see i wanted to see how many
00:21:14 - 00:21:19: double l's were inside of this string
00:21:16 - 00:21:20: well i can say hello.count double l and
00:21:19 - 00:21:21: then that will count and tell me how
00:21:20 - 00:21:23: many are in here
00:21:21 - 00:21:25: now have a look and guess how many you
00:21:23 - 00:21:27: think are in here well there's actually
00:21:25 - 00:21:28: zero the reason they're zero is because
00:21:27 - 00:21:30: these are capital l's and this was
00:21:28 - 00:21:31: looking for lowercase l's
00:21:30 - 00:21:33: so that's why it's very important to
00:21:31 - 00:21:34: make sure you're differentiating between
00:21:33 - 00:21:37: capitals and lowercases
00:21:34 - 00:21:38: because two lowercase l's are not the
00:21:37 - 00:21:40: same as two uppercase l's
00:21:38 - 00:21:41: but if i wanted to fix this problem i
00:21:40 - 00:21:43: could make the entire string lowercase
00:21:41 - 00:21:46: so i could say hello dot lower
00:21:43 - 00:21:47: and then i could count all of the double
00:21:46 - 00:21:48: l's in the lowercase string
00:21:47 - 00:21:50: so now let's look at this in this case
00:21:48 - 00:21:52: we get the value one let's make this a
00:21:50 - 00:21:52: little bit better and let's look for all
00:21:52 - 00:21:54: of
00:21:52 - 00:21:55: the is there any other ones that we can
00:21:54 - 00:21:57: look for i guess we can look for how
00:21:55 - 00:21:59: many o's there are
00:21:57 - 00:22:01: all right in that case we get two o's so
00:21:59 - 00:22:02: those are a few basic string methods
00:22:01 - 00:22:04: there are some more but i just want to
00:22:02 - 00:22:06: show you how you use these
00:22:04 - 00:22:07: and the fact that you can chain them on
00:22:06 - 00:22:08: each other because what happens is this
00:22:07 - 00:22:10: will return a string
00:22:08 - 00:22:12: you can imagine that the substitution of
00:22:10 - 00:22:14: this just looks like um you know
00:22:12 - 00:22:16: hello world and then it's going to count
00:22:14 - 00:22:18: all the o's inside of hello world and
00:22:16 - 00:22:18: return to us that value which in this
00:22:18 - 00:22:20: case was
00:22:18 - 00:22:22: 2. all right so now we're going to move
00:22:20 - 00:22:22: on to conditions and conditional
00:22:22 - 00:22:24: operators
00:22:22 - 00:22:25: now before i mention that i just want to
00:22:24 - 00:22:27: go over something that i forgot in one
00:22:25 - 00:22:29: of the previous sections this is simply
00:22:27 - 00:22:30: string multiplication and string
00:22:29 - 00:22:31: addition
00:22:30 - 00:22:33: this is important so i'm just going to
00:22:31 - 00:22:34: cover it quickly but essentially let's
00:22:33 - 00:22:35: say i have a variable and that's equal
00:22:34 - 00:22:37: to
00:22:35 - 00:22:38: hello so x equals to a low i have
00:22:37 - 00:22:40: another variable and this is equal to
00:22:38 - 00:22:42: actually we can say 3.
00:22:40 - 00:22:44: well there's this cool thing in python
00:22:42 - 00:22:45: but what i can actually do is multiply a
00:22:44 - 00:22:47: string by an integer
00:22:45 - 00:22:48: and that will simply repeat the string
00:22:47 - 00:22:51: the integer number times
00:22:48 - 00:22:53: so if i say x multiplied by y even
00:22:51 - 00:22:54: though these aren't the same data type
00:22:53 - 00:22:56: which i said before
00:22:54 - 00:22:58: might cause problems since it's a string
00:22:56 - 00:22:59: and it's an integer and the string is on
00:22:58 - 00:23:01: the left hand side
00:22:59 - 00:23:02: we can do this so i can say how this
00:23:01 - 00:23:04: gives us hello
00:23:02 - 00:23:06: because we multiplied the string by the
00:23:04 - 00:23:06: integer so just something to keep in
00:23:06 - 00:23:08: mind
00:23:06 - 00:23:10: that we also can add two strings
00:23:08 - 00:23:11: together because that actually makes
00:23:10 - 00:23:12: sense so if i say hello and then i say
00:23:11 - 00:23:14: yes
00:23:12 - 00:23:16: well i can add these two together this
00:23:14 - 00:23:17: is known as a concatenation so let's
00:23:16 - 00:23:20: have a look at this
00:23:17 - 00:23:22: and i get hello and then yes so you can
00:23:20 - 00:23:23: do that you can add two strings together
00:23:22 - 00:23:26: and you can multiply a string by an
00:23:23 - 00:23:27: integer just need to throw that in there
00:23:26 - 00:23:29: because that obviously is something
00:23:27 - 00:23:31: that's important to understand
00:23:29 - 00:23:33: all right next we're going to talk about
00:23:31 - 00:23:35: conditions and conditional operators
00:23:33 - 00:23:37: so a condition is simply something in
00:23:35 - 00:23:38: python that evaluates or compares two
00:23:37 - 00:23:41: variables or data types
00:23:38 - 00:23:43: and returns to us either a true or false
00:23:41 - 00:23:45: value based on the comparison
00:23:43 - 00:23:46: so to you know give you an example of a
00:23:45 - 00:23:48: comparison is x
00:23:46 - 00:23:50: equal to y is x less than y those are
00:23:48 - 00:23:52: comparisons and the answer to that is
00:23:50 - 00:23:53: either yes or no or in our case true or
00:23:52 - 00:23:55: false
00:23:53 - 00:23:56: so we have that true and we have these
00:23:55 - 00:23:58: false
00:23:56 - 00:24:01: this is boolean so the result of a
00:23:58 - 00:24:02: comparison is simply a boolean value
00:24:01 - 00:24:04: all right so let's look at what these
00:24:02 - 00:24:05: operators are we have two equal signs
00:24:04 - 00:24:07: which checks for equality
00:24:05 - 00:24:09: is the left-hand side equal to the
00:24:07 - 00:24:11: right-hand side we have not equal to
00:24:09 - 00:24:13: which checks for inequality
00:24:11 - 00:24:14: so is the left-hand side not equal to
00:24:13 - 00:24:16: the right-hand side
00:24:14 - 00:24:18: we have less than or equal to greater
00:24:16 - 00:24:19: than or equal to less than and
00:24:18 - 00:24:20: greater than now there's a few other
00:24:19 - 00:24:22: random ones we're not going to go
00:24:20 - 00:24:23: through those but these are the core
00:24:22 - 00:24:25: conditional operators and let me show
00:24:23 - 00:24:25: you an example of condition let's say i
00:24:25 - 00:24:29: have x
00:24:25 - 00:24:31: equals hello and
00:24:29 - 00:24:32: y equals hello i want to check for the
00:24:31 - 00:24:33: comparison so i might do something like
00:24:32 - 00:24:36: print
00:24:33 - 00:24:36: x equals equals y are these two things
00:24:36 - 00:24:39: the same
00:24:36 - 00:24:41: let's see yes they are we get the value
00:24:39 - 00:24:43: true now let's do the not equal to sign
00:24:41 - 00:24:45: are these things not the same no they're
00:24:43 - 00:24:46: not so we get false that is the basics
00:24:45 - 00:24:49: of checking for
00:24:46 - 00:24:50: equality now what if i add a capital l
00:24:49 - 00:24:52: inside of this string well we know that
00:24:50 - 00:24:53: lowercase and capital l's are different
00:24:52 - 00:24:55: so if i do this
00:24:53 - 00:24:56: we get true which means no these two
00:24:55 - 00:24:57: strings are not the same they are
00:24:56 - 00:24:59: different
00:24:57 - 00:25:01: if i do double equal sign then we get
00:24:59 - 00:25:02: false now interesting thing with strings
00:25:01 - 00:25:03: we can actually compare them using the
00:25:02 - 00:25:05: greater than sign
00:25:03 - 00:25:07: and less than sign now it's not super
00:25:05 - 00:25:09: intuitive so i have to kind of show some
00:25:07 - 00:25:10: more primitive examples here to give you
00:25:09 - 00:25:12: an illustration of how this works but if
00:25:10 - 00:25:14: i have something like a
00:25:12 - 00:25:16: and i say is a greater than let's
00:25:14 - 00:25:18: actually go with capital z
00:25:16 - 00:25:20: what do you think the answer to that is
00:25:18 - 00:25:21: well that's actually true
00:25:20 - 00:25:23: now the reason for that is every single
00:25:21 - 00:25:25: character inside of python is
00:25:23 - 00:25:26: represented by what's known as an ascii
00:25:25 - 00:25:27: code
00:25:26 - 00:25:28: we actually have a look at what this
00:25:27 - 00:25:31: ascii code is by looking at what's
00:25:28 - 00:25:32: called the ordinal value of a character
00:25:31 - 00:25:34: so if i print out the ordinal of z we
00:25:32 - 00:25:36: can actually see that that's 90.
00:25:34 - 00:25:37: if i print out the ordinal of a we can
00:25:36 - 00:25:39: actually see that that's 97.
00:25:37 - 00:25:41: so what that's telling us essentially is
00:25:39 - 00:25:44: that this uppercase z
00:25:41 - 00:25:46: is actually represented by the number 90
00:25:44 - 00:25:47: and the uppercase or sorry the lowercase
00:25:46 - 00:25:49: a is
00:25:47 - 00:25:51: represented by 97. so what we do is we
00:25:49 - 00:25:52: would compare the two ordinal values of
00:25:51 - 00:25:54: these character
00:25:52 - 00:25:56: characters and see that well actually a
00:25:54 - 00:25:59: is greater than z
00:25:56 - 00:26:00: now if we do this so i say a greater
00:25:59 - 00:26:01: than b then that's going to be false
00:26:00 - 00:26:03: because b
00:26:01 - 00:26:05: is actually represented by 98 there is
00:26:03 - 00:26:06: some logical ordering for these
00:26:05 - 00:26:07: characters
00:26:06 - 00:26:09: but i just want you to understand that
00:26:07 - 00:26:09: we can compare strings using greater
00:26:09 - 00:26:11: than less than
00:26:09 - 00:26:12: equal to all of those but just
00:26:11 - 00:26:14: understand that we're comparing the
00:26:12 - 00:26:16: ordinal value of the strings now let's
00:26:14 - 00:26:17: say we have something like a b
00:26:16 - 00:26:19: what we're going to do is simply just go
00:26:17 - 00:26:20: from left to right and compare
00:26:19 - 00:26:23: all of the characters so we would say
00:26:20 - 00:26:25: okay is a greater than b
00:26:23 - 00:26:26: yes it is imagine these two are the same
00:26:25 - 00:26:29: so we had a and then we had d
00:26:26 - 00:26:30: like that if these were the same then we
00:26:29 - 00:26:31: would go on and compare the next
00:26:30 - 00:26:33: character which would be
00:26:31 - 00:26:35: b in this case we get false because
00:26:33 - 00:26:38: obviously the d is greater
00:26:35 - 00:26:39: all right so that is how that works now
00:26:38 - 00:26:40: let's just show a few examples of
00:26:39 - 00:26:44: numbers
00:26:40 - 00:26:46: let's just say 7.5 equals equals 7.
00:26:44 - 00:26:48: is that true obviously that's false
00:26:46 - 00:26:50: let's say 7.5 greater than 7.
00:26:48 - 00:26:52: obviously that's going to be true and
00:26:50 - 00:26:54: what about 7.0
00:26:52 - 00:26:55: equals equals 7. have a look at that we
00:26:54 - 00:26:57: get true
00:26:55 - 00:26:59: all right that is the basics on the
00:26:57 - 00:27:00: conditional operators and
00:26:59 - 00:27:02: conditions of course you can store these
00:27:00 - 00:27:04: things in variables i can say result
00:27:02 - 00:27:08: equals 6 equals equals 6.
00:27:04 - 00:27:11: and print result
00:27:08 - 00:27:12: like that and we get the value true okay
00:27:11 - 00:27:13: let's move on now to chained
00:27:12 - 00:27:15: conditionals
00:27:13 - 00:27:18: so a chained conditional is essentially
00:27:15 - 00:27:19: combining multiple conditions together
00:27:18 - 00:27:21: to create one
00:27:19 - 00:27:22: larger condition what i have right here
00:27:21 - 00:27:24: is a basic example
00:27:22 - 00:27:26: i have three conditions right i have
00:27:24 - 00:27:27: result one result two and result three
00:27:26 - 00:27:29: result one says is x
00:27:27 - 00:27:31: equal to y result two says is y greater
00:27:29 - 00:27:33: than x and this one said
00:27:31 - 00:27:35: is z less than x plus two you can
00:27:33 - 00:27:37: imagine that these have brackets around
00:27:35 - 00:27:39: it it works the same
00:27:37 - 00:27:41: so all of our conditional operators have
00:27:39 - 00:27:43: a lower precedence than all of the
00:27:41 - 00:27:45: arithmetic operators so if i do
00:27:43 - 00:27:48: something like z minus two
00:27:45 - 00:27:48: less than x plus two well that's not
00:27:48 - 00:27:50: going to say z
00:27:48 - 00:27:52: and then negative 2 less than that it
00:27:50 - 00:27:53: will evaluate on the left hand side and
00:27:52 - 00:27:55: it will evaluate on the right hand side
00:27:53 - 00:27:58: and then it will combine
00:27:55 - 00:28:00: and use sorry this conditional operator
00:27:58 - 00:28:01: so hopefully that makes sense
00:28:00 - 00:28:03: but just keep that in mind that you can
00:28:01 - 00:28:04: actually write expressions on each side
00:28:03 - 00:28:06: of
00:28:04 - 00:28:07: a conditional operator okay so now that
00:28:06 - 00:28:08: we have that
00:28:07 - 00:28:10: essentially what i want to do is say
00:28:08 - 00:28:13: okay how can i make a condition that
00:28:10 - 00:28:14: uses result 1 result 2 and result 3.
00:28:13 - 00:28:16: so obviously all of these are equal to
00:28:14 - 00:28:17: true false true false
00:28:16 - 00:28:19: they're equal to something like that so
00:28:17 - 00:28:22: what i can actually do is use
00:28:19 - 00:28:25: three separate keywords so and or
00:28:22 - 00:28:27: oops and not so these three words are
00:28:25 - 00:28:28: what i can use to chain conditionals
00:28:27 - 00:28:31: together and create larger
00:28:28 - 00:28:32: larger conditions from specific
00:28:31 - 00:28:33: conditions themselves
00:28:32 - 00:28:35: so what i can do is do something like
00:28:33 - 00:28:39: this i can say result 4
00:28:35 - 00:28:41: equals result 1 or result 2.
00:28:39 - 00:28:43: now what does the or operator do well
00:28:41 - 00:28:45: the left hand side and the right hand
00:28:43 - 00:28:46: side of or have to be a true or false
00:28:45 - 00:28:48: value which they are because these
00:28:46 - 00:28:49: evaluate to true or false
00:28:48 - 00:28:51: what or will do is it will look at the
00:28:49 - 00:28:52: left hand side and right hand side it
00:28:51 - 00:28:54: will say okay
00:28:52 - 00:28:56: if the left hand side is true or the
00:28:54 - 00:28:58: right hand side is true
00:28:56 - 00:29:00: this whole condition is true of course
00:28:58 - 00:29:01: if they're both false that's the only
00:29:00 - 00:29:02: situation
00:29:01 - 00:29:04: where this whole condition here is going
00:29:02 - 00:29:06: to be false so in three scenarios
00:29:04 - 00:29:06: because there's four possible scenarios
00:29:06 - 00:29:07: here
00:29:06 - 00:29:09: it's going to be true and the other
00:29:07 - 00:29:10: scenario it will be false so if both of
00:29:09 - 00:29:11: these are true
00:29:10 - 00:29:13: obviously at least one of them was true
00:29:11 - 00:29:15: so that evaluates to true so let's
00:29:13 - 00:29:18: actually just print
00:29:15 - 00:29:18: result 4 and have a look at it great we
00:29:18 - 00:29:20: get true
00:29:18 - 00:29:23: now what we can do is we can add another
00:29:20 - 00:29:26: or if we want and we can say result 3.
00:29:23 - 00:29:28: now what this says is ok if result 1 or
00:29:26 - 00:29:31: result 2 or result 3 is true this whole
00:29:28 - 00:29:32: thing is true which of course it is
00:29:31 - 00:29:34: now let's see how we can combine other
00:29:32 - 00:29:36: stuff into this we can actually use this
00:29:34 - 00:29:37: not keyword what this does is it takes
00:29:36 - 00:29:39: whatever
00:29:37 - 00:29:40: is on the right hand side of it so in
00:29:39 - 00:29:41: this case it's going to be a true or
00:29:40 - 00:29:44: false value
00:29:41 - 00:29:44: and just flips it so in this case if if
00:29:44 - 00:29:46: result 2
00:29:44 - 00:29:48: is true which it is it's just
00:29:46 - 00:29:50: automatically going to become false
00:29:48 - 00:29:52: so if i actually i can show you on a
00:29:50 - 00:29:54: more basic level
00:29:52 - 00:29:55: if i just print a instead of result 4 i
00:29:54 - 00:29:58: print
00:29:55 - 00:30:00: not true like that this will print the
00:29:58 - 00:30:03: value false which you can see down there
00:30:00 - 00:30:05: and if i print not false then
00:30:03 - 00:30:08: this will print true now what i can do
00:30:05 - 00:30:11: is do something like this i can say not
00:30:08 - 00:30:11: false or true so let's have a look at
00:30:11 - 00:30:13: that
00:30:11 - 00:30:14: and there we go we get false so it takes
00:30:13 - 00:30:16: whatever this is which is true
00:30:14 - 00:30:18: and then it just reverses it and makes
00:30:16 - 00:30:20: it with the not now those are two that
00:30:18 - 00:30:21: we've talked about so or and not now
00:30:20 - 00:30:23: what about and
00:30:21 - 00:30:24: so and essentially says okay is what's
00:30:23 - 00:30:26: on the left hand side
00:30:24 - 00:30:27: and the right hand side true if both of
00:30:26 - 00:30:29: it is true
00:30:27 - 00:30:32: they are true the whole condition sorry
00:30:29 - 00:30:33: is true otherwise it is false so only in
00:30:32 - 00:30:35: one scenario out of the
00:30:33 - 00:30:37: four possible scenarios here with two
00:30:35 - 00:30:38: variables or two values on the left and
00:30:37 - 00:30:39: right hand side
00:30:38 - 00:30:41: is this going to be true so let's have a
00:30:39 - 00:30:42: look at this and we get true because
00:30:41 - 00:30:44: obviously this is false
00:30:42 - 00:30:46: then we nod it and that turns to true
00:30:44 - 00:30:49: now of course we can do a combination of
00:30:46 - 00:30:50: and and or now when we use these
00:30:49 - 00:30:53: combination of different things right so
00:30:50 - 00:30:54: not and or we have to know which is
00:30:53 - 00:30:56: going to come before what so kind of in
00:30:54 - 00:30:58: the order of operations
00:30:56 - 00:30:59: now the way it actually goes is not is
00:30:58 - 00:31:02: first and
00:30:59 - 00:31:03: is second and or is last so just keep
00:31:02 - 00:31:04: that in mind because that will be
00:31:03 - 00:31:05: important based on the way that you
00:31:04 - 00:31:08: write your expression so essentially if
00:31:05 - 00:31:09: i say false and true or true
00:31:08 - 00:31:11: then what we're going to actually do is
00:31:09 - 00:31:14: evaluate the false and true
00:31:11 - 00:31:15: first and then we will evaluate the or
00:31:14 - 00:31:17: of whatever this is
00:31:15 - 00:31:19: and then that so in this case this would
00:31:17 - 00:31:20: be false so then we would get false or
00:31:19 - 00:31:23: true and then this would turn
00:31:20 - 00:31:26: into true then we would have the not
00:31:23 - 00:31:28: and that would turn that into the false
00:31:26 - 00:31:30: so now we're moving on to the fun stuff
00:31:28 - 00:31:30: which in my opinion is the if else if
00:31:30 - 00:31:32: and
00:31:30 - 00:31:34: else statement now this essentially
00:31:32 - 00:31:37: allows us to actually check
00:31:34 - 00:31:37: if something occurs or if a condition is
00:31:37 - 00:31:39: true
00:31:37 - 00:31:40: and if that is true we can do something
00:31:39 - 00:31:42: specific
00:31:40 - 00:31:44: otherwise we might not do anything or we
00:31:42 - 00:31:45: might do something differently so for
00:31:44 - 00:31:47: the example i'm going to do here i want
00:31:45 - 00:31:49: someone to type in their name
00:31:47 - 00:31:51: and i want to say if their name is equal
00:31:49 - 00:31:53: to in this case tim
00:31:51 - 00:31:54: i will tell them they are good at python
00:31:53 - 00:31:56: i don't know something random
00:31:54 - 00:31:58: so in this case to do that what i will
00:31:56 - 00:32:00: start doing is writing an if statement
00:31:58 - 00:32:03: so the syntax of an if statement is if
00:32:00 - 00:32:05: condition like that i know that's
00:32:03 - 00:32:08: spelled wrong but that's fine condition
00:32:05 - 00:32:10: colon indented block whatever i want to
00:32:08 - 00:32:10: happen in the indented block and then
00:32:10 - 00:32:12: that is
00:32:10 - 00:32:14: the basic syntax of the if statement so
00:32:12 - 00:32:17: for here if i want to check if
00:32:14 - 00:32:19: x is equal to tim i will say if x equal
00:32:17 - 00:32:20: equal to and then the string tim with
00:32:19 - 00:32:24: the capital t
00:32:20 - 00:32:28: i will simply print you are
00:32:24 - 00:32:30: great so now what will happen is if and
00:32:28 - 00:32:31: only if x is equal to tim will i print
00:32:30 - 00:32:34: you are great
00:32:31 - 00:32:35: now in any situation so regardless of if
00:32:34 - 00:32:37: the name is equal to tim or not i will
00:32:35 - 00:32:38: always do this so i will print that
00:32:37 - 00:32:39: statement
00:32:38 - 00:32:41: hopefully that's self-explanatory so
00:32:39 - 00:32:42: let's go ahead and do tim we can see you
00:32:41 - 00:32:44: are great always do this
00:32:42 - 00:32:46: now let's do another name let's go with
00:32:44 - 00:32:47: joe and it says always do this it did
00:32:46 - 00:32:49: not
00:32:47 - 00:32:51: print this statement now the addition to
00:32:49 - 00:32:52: the if statement is of course i can add
00:32:51 - 00:32:54: more stuff
00:32:52 - 00:32:56: underneath this indented block so i do
00:32:54 - 00:32:57: another print statement and that would
00:32:56 - 00:32:59: add a space so let me actually just show
00:32:57 - 00:33:01: you how this works if i do
00:32:59 - 00:33:03: tim now you see we get that space by
00:33:01 - 00:33:05: just printing an empty
00:33:03 - 00:33:07: print statement essentially okay now
00:33:05 - 00:33:10: what we can do though is we can say okay
00:33:07 - 00:33:10: how about i only want to print you are
00:33:10 - 00:33:12: great
00:33:10 - 00:33:13: or i want to print some other message i
00:33:12 - 00:33:15: don't want to print two things
00:33:13 - 00:33:17: well what i can do is i can print i can
00:33:15 - 00:33:19: add this else this else
00:33:17 - 00:33:20: must come after an if statement and
00:33:19 - 00:33:21: essentially what it allows me to do is
00:33:20 - 00:33:24: say okay
00:33:21 - 00:33:26: if this isn't true do this so it's an if
00:33:24 - 00:33:29: else right if true
00:33:26 - 00:33:29: do this otherwise do this never will i
00:33:29 - 00:33:32: do both
00:33:29 - 00:33:33: so in this case i'll just print no you
00:33:32 - 00:33:34: know not very
00:33:33 - 00:33:36: intuitive or it doesn't really make much
00:33:34 - 00:33:39: sense but that's fine so now
00:33:36 - 00:33:41: i'll go ahead and i'll say name tim
00:33:39 - 00:33:43: it says you are great and let's actually
00:33:41 - 00:33:46: just go with no and then
00:33:43 - 00:33:47: it prints out no all right so that's the
00:33:46 - 00:33:49: basics on the if
00:33:47 - 00:33:51: else now let's say we actually want to
00:33:49 - 00:33:52: check multiple things so maybe we want
00:33:51 - 00:33:54: to check
00:33:52 - 00:33:56: a bunch of different names and if the
00:33:54 - 00:33:57: name is joe maybe we want to say
00:33:56 - 00:33:59: you know thanks joe i don't know
00:33:57 - 00:34:00: something random right well what we can
00:33:59 - 00:34:02: do is use this elif
00:34:00 - 00:34:04: statement the l if statement can be used
00:34:02 - 00:34:07: as many times as we want
00:34:04 - 00:34:08: but it must come after an if and it must
00:34:07 - 00:34:10: be before
00:34:08 - 00:34:11: any elses so i can't just go ahead and
00:34:10 - 00:34:12: start writing these random elifs
00:34:11 - 00:34:13: everywhere
00:34:12 - 00:34:15: it only is going to come after an if
00:34:13 - 00:34:18: statement so there's only ever
00:34:15 - 00:34:19: one if only ever one else but as many
00:34:18 - 00:34:20: lifts as we want and you'll see how this
00:34:19 - 00:34:22: works in a second
00:34:20 - 00:34:24: so the l of syntax is the exact same
00:34:22 - 00:34:26: except it starts with the el
00:34:24 - 00:34:27: so i'm going to say l if x equals equals
00:34:26 - 00:34:31: joe
00:34:27 - 00:34:34: and i'm going to print by
00:34:31 - 00:34:35: joe why not so now let's run this let me
00:34:34 - 00:34:36: just show you what happens when i go
00:34:35 - 00:34:38: with joe
00:34:36 - 00:34:39: it says buy joe and let's just print
00:34:38 - 00:34:42: something random it gives
00:34:39 - 00:34:42: us no now of course i don't need this
00:34:42 - 00:34:44: else statement
00:34:42 - 00:34:46: i can use an life without the else
00:34:44 - 00:34:47: statement that's totally valid
00:34:46 - 00:34:49: in this situation if i do something
00:34:47 - 00:34:51: random just nothing will happen but if i
00:34:49 - 00:34:52: put tim or joe then it will give me the
00:34:51 - 00:34:55: valid response
00:34:52 - 00:34:56: now let's add another lf let's say lfx
00:34:55 - 00:34:57: equals equals i don't know let's go with
00:34:56 - 00:35:01: sarah
00:34:57 - 00:35:04: we can print random okay
00:35:01 - 00:35:05: and now let's try this out and that
00:35:04 - 00:35:07: works now of course we could add the
00:35:05 - 00:35:08: else at the end but that is the basics
00:35:07 - 00:35:09: for the if
00:35:08 - 00:35:12: l if and else now of course you can
00:35:09 - 00:35:13: chain and add stuff inside of another if
00:35:12 - 00:35:14: statement i could put another if
00:35:13 - 00:35:15: statement inside of this
00:35:14 - 00:35:17: but just make sure you keep the
00:35:15 - 00:35:19: indentation correct because that how it
00:35:17 - 00:35:21: that is how it determines what we are
00:35:19 - 00:35:22: going to be printing and what we are
00:35:21 - 00:35:24: doing
00:35:22 - 00:35:25: if this statement is true so in these
00:35:24 - 00:35:27: next few sections i'm going to be
00:35:25 - 00:35:28: talking about collections how we deal
00:35:27 - 00:35:30: with collections looping over
00:35:28 - 00:35:32: collections and all
00:35:30 - 00:35:33: of that fun stuff but what is a
00:35:32 - 00:35:35: collection well collection is simply an
00:35:33 - 00:35:37: unordered or ordered group
00:35:35 - 00:35:39: of elements now the two collections i'm
00:35:37 - 00:35:41: going to discuss here in this section
00:35:39 - 00:35:42: is list and tuples so if we have a list
00:35:41 - 00:35:44: a list looks something like this it is
00:35:42 - 00:35:45: simply square brackets
00:35:44 - 00:35:47: now inside of the square brackets we can
00:35:45 - 00:35:48: have a series of elements elements are
00:35:47 - 00:35:51: simply some
00:35:48 - 00:35:52: data type so i could have the integer 4
00:35:51 - 00:35:55: i could have the value
00:35:52 - 00:35:56: true i could have some string high and
00:35:55 - 00:35:58: these
00:35:56 - 00:36:00: elements do not need to be the same type
00:35:58 - 00:36:00: like in many other languages so this is
00:36:00 - 00:36:02: a
00:36:00 - 00:36:04: list and the way that the list works is
00:36:02 - 00:36:05: that it can store a bunch of different
00:36:04 - 00:36:07: elements and a list is an
00:36:05 - 00:36:09: ordered collection which means the order
00:36:07 - 00:36:11: in which we enter things into the
00:36:09 - 00:36:12: collection matters and is maintained in
00:36:11 - 00:36:15: fact it's
00:36:12 - 00:36:16: very important in the list so how do i
00:36:15 - 00:36:18: actually access elements in the list how
00:36:16 - 00:36:19: do i deal with the list what are some
00:36:18 - 00:36:21: things we can do with it
00:36:19 - 00:36:22: well of course i can define a list by
00:36:21 - 00:36:24: simply opening up some square brackets
00:36:22 - 00:36:26: and then defining some elements inside
00:36:24 - 00:36:28: i also can just leave square brackets
00:36:26 - 00:36:29: like this empty that would give me an
00:36:28 - 00:36:30: empty list
00:36:29 - 00:36:32: the first thing to look at on a list is
00:36:30 - 00:36:34: this function called len
00:36:32 - 00:36:36: len will tell us the length of the list
00:36:34 - 00:36:37: this also works on strings and a few
00:36:36 - 00:36:39: other things as well
00:36:37 - 00:36:41: but if i look at the len of x that tells
00:36:39 - 00:36:42: me 3. now just to kind of show you here
00:36:41 - 00:36:45: if i say
00:36:42 - 00:36:48: y equals high and i were to look at the
00:36:45 - 00:36:50: len of y after i look at the line of x
00:36:48 - 00:36:52: we obviously get 2. so len is a function
00:36:50 - 00:36:53: in python that we can use to look at the
00:36:52 - 00:36:54: lengths of stuff
00:36:53 - 00:36:56: all right so that is one of the things
00:36:54 - 00:36:58: we can do on a list what we can also do
00:36:56 - 00:37:00: is we can append things to it
00:36:58 - 00:37:02: what a pen does is add to the end of the
00:37:00 - 00:37:02: list so if i want to add say the element
00:37:02 - 00:37:05: hello
00:37:02 - 00:37:07: i can say x dot append now i can print
00:37:05 - 00:37:07: out x and if we have a look we get four
00:37:07 - 00:37:09: true
00:37:07 - 00:37:11: high hello of course we added this
00:37:09 - 00:37:13: element to the end of the list
00:37:11 - 00:37:15: i can also extend the list by another
00:37:13 - 00:37:18: list so let's say i have a list here
00:37:15 - 00:37:20: and inside of this list i have 4 5 and
00:37:18 - 00:37:22: just a bunch of other stuff
00:37:20 - 00:37:23: well when i extend it what that will do
00:37:22 - 00:37:25: is take all of the elements from this
00:37:23 - 00:37:26: list and simply append each of them to
00:37:25 - 00:37:28: the end of the list
00:37:26 - 00:37:30: so you can imagine extend its internal
00:37:28 - 00:37:30: implementation just loops through all of
00:37:30 - 00:37:33: this and
00:37:30 - 00:37:35: appends all of those elements to this
00:37:33 - 00:37:37: list now what about removing something
00:37:35 - 00:37:38: or popping something off of the list
00:37:37 - 00:37:40: well i kind of already gave away what
00:37:38 - 00:37:41: one of these things is but what pop does
00:37:40 - 00:37:44: is remove
00:37:41 - 00:37:46: and return the last element in the list
00:37:44 - 00:37:49: so if i actually go ahead
00:37:46 - 00:37:50: and print x dot pop what this will do is
00:37:49 - 00:37:52: it will print high
00:37:50 - 00:37:54: and it will remove high from the list
00:37:52 - 00:37:56: and you can see that when we print x
00:37:54 - 00:37:58: again so we get high and now our list
00:37:56 - 00:37:59: has high remove because we popped it off
00:37:58 - 00:38:02: of the end
00:37:59 - 00:38:03: now another argument for pop is actually
00:38:02 - 00:38:05: the index
00:38:03 - 00:38:07: of what we want to remove when we look
00:38:05 - 00:38:07: at a list every single element in the
00:38:07 - 00:38:09: list
00:38:07 - 00:38:11: is identified by a number that number is
00:38:09 - 00:38:13: known as its index otherwise known as
00:38:11 - 00:38:14: its position in the list
00:38:13 - 00:38:17: when we start looking at indexes in a
00:38:14 - 00:38:19: list we start counting at zero
00:38:17 - 00:38:21: so the first position in the list is 0
00:38:19 - 00:38:23: the next is 1 and the last is
00:38:21 - 00:38:25: 2. if we want to know the last index in
00:38:23 - 00:38:27: a list we look at the length of the list
00:38:25 - 00:38:29: and subtract 1. in this case we have 3
00:38:27 - 00:38:30: elements the last index would be 2 the
00:38:29 - 00:38:32: first is 0.
00:38:30 - 00:38:33: so if i go ahead and say x dot pop 0
00:38:32 - 00:38:35: what that's going to do is remove the
00:38:33 - 00:38:37: first element from the list which is 4.
00:38:35 - 00:38:38: so now we remove that and all of a
00:38:37 - 00:38:40: sudden if we look at this new list the
00:38:38 - 00:38:42: first element at position 0
00:38:40 - 00:38:44: index 0 is going to be true now if we
00:38:42 - 00:38:45: simply want to access elements of the
00:38:44 - 00:38:46: list maybe we don't want to remove them
00:38:45 - 00:38:49: we just want to look at them
00:38:46 - 00:38:50: we can say x put these square brackets
00:38:49 - 00:38:51: which means we're going to access
00:38:50 - 00:38:53: something
00:38:51 - 00:38:55: and we can put the index of the element
00:38:53 - 00:38:57: that we want to access in this case
00:38:55 - 00:38:59: we'll access true
00:38:57 - 00:39:00: there we go we print true and that is
00:38:59 - 00:39:02: the basics
00:39:00 - 00:39:03: now what i can also do is do something
00:39:02 - 00:39:06: like x 0 equals
00:39:03 - 00:39:08: and change its value to say hello now
00:39:06 - 00:39:11: when i print x we'll get hello true hi
00:39:08 - 00:39:13: let's have a look and there we go the
00:39:11 - 00:39:13: reason i can do this is because lists
00:39:13 - 00:39:17: are what's known as
00:39:13 - 00:39:19: mutable this means this x right here
00:39:17 - 00:39:20: does not actually store a copy to the
00:39:19 - 00:39:22: list it stores what's known as a
00:39:20 - 00:39:24: reference to the list
00:39:22 - 00:39:25: and the actual items itself are stored
00:39:24 - 00:39:26: somewhere else
00:39:25 - 00:39:28: so for people that are more advanced and
00:39:26 - 00:39:29: understand that i'm hoping if you guys
00:39:28 - 00:39:30: have come from another programming
00:39:29 - 00:39:32: language that makes sense
00:39:30 - 00:39:35: but lists are mutable which means they
00:39:32 - 00:39:35: can be changed i can change all of these
00:39:35 - 00:39:38: elements
00:39:35 - 00:39:41: and if i do something like y equals x
00:39:38 - 00:39:42: i go ahead and i make that change to x
00:39:41 - 00:39:44: but i don't make it to y you're going to
00:39:42 - 00:39:45: notice that x and y will be the exact
00:39:44 - 00:39:47: same
00:39:45 - 00:39:49: so i have hello true high hello true
00:39:47 - 00:39:52: high making a modification to x
00:39:49 - 00:39:54: made a modification to y because x and y
00:39:52 - 00:39:56: are storing a reference to this list not
00:39:54 - 00:39:58: a copy of this list if i wanted to copy
00:39:56 - 00:39:59: the list i would have to do this
00:39:58 - 00:40:01: i would have to do two square brackets a
00:39:59 - 00:40:02: colon inside we'll talk about how this
00:40:01 - 00:40:04: works
00:40:02 - 00:40:06: later but now notice if i made this copy
00:40:04 - 00:40:06: that change does not apply to the other
00:40:06 - 00:40:08: list
00:40:06 - 00:40:09: there's a lot of other stuff that you
00:40:08 - 00:40:10: can do with lists but those are the
00:40:09 - 00:40:12: basics and
00:40:10 - 00:40:13: hopefully that makes sense next i'm
00:40:12 - 00:40:15: going to talk about tuples
00:40:13 - 00:40:16: so tuples are similar to lists except
00:40:15 - 00:40:18: they are immutable
00:40:16 - 00:40:20: so a tuple uses round brackets instead
00:40:18 - 00:40:22: of square brackets
00:40:20 - 00:40:24: and it works pretty much the exact same
00:40:22 - 00:40:26: except we cannot append we cannot remove
00:40:24 - 00:40:28: and we cannot change
00:40:26 - 00:40:29: elements so a tuple is really an
00:40:28 - 00:40:31: immutable list you can think of it like
00:40:29 - 00:40:32: that it means it cannot be changed once
00:40:31 - 00:40:34: it has been defined
00:40:32 - 00:40:36: if we want to change it we actually have
00:40:34 - 00:40:38: to redefine it so what i can do is i can
00:40:36 - 00:40:39: print out say x0
00:40:38 - 00:40:41: and that's fine that will give me the
00:40:39 - 00:40:44: correct answer so that will give me zero
00:40:41 - 00:40:47: but if i go ahead and do something like
00:40:44 - 00:40:48: x 0 equals 5 and i try to do that
00:40:47 - 00:40:50: you're going to notice we get an error
00:40:48 - 00:40:52: because the tuple object does not
00:40:50 - 00:40:54: support item assignment
00:40:52 - 00:40:56: reason for that is because again it is
00:40:54 - 00:40:57: immutable i also cannot do something
00:40:56 - 00:40:59: like x dot append
00:40:57 - 00:41:00: i can try but you're going to notice
00:40:59 - 00:41:03: that again we'll get another error
00:41:00 - 00:41:04: tuple object has no attribute append so
00:41:03 - 00:41:06: this is a tuple
00:41:04 - 00:41:08: they're not used a ton although they are
00:41:06 - 00:41:09: used sometimes and just to note here you
00:41:08 - 00:41:10: can have
00:41:09 - 00:41:12: lists inside of lists so i can say
00:41:10 - 00:41:14: something like you know i could have a
00:41:12 - 00:41:16: tuple inside of a list i could have
00:41:14 - 00:41:18: a list inside of a list inside of a list
00:41:16 - 00:41:20: and i could have elements inside of this
00:41:18 - 00:41:22: they don't need to be uniform size
00:41:20 - 00:41:23: sometimes in other programming languages
00:41:22 - 00:41:25: when you're looking at a raise
00:41:23 - 00:41:26: if you have embedded lists every element
00:41:25 - 00:41:28: has to be another list
00:41:26 - 00:41:30: stuff like that just wanted to point out
00:41:28 - 00:41:30: that you can do something like that
00:41:30 - 00:41:32: and i think that's all i'm going to
00:41:30 - 00:41:34: cover right now for lists and tuples all
00:41:32 - 00:41:36: right the next topic i have for you
00:41:34 - 00:41:38: is for loops now a for loop if you've
00:41:36 - 00:41:38: learned in other programming languages
00:41:38 - 00:41:41: allow us
00:41:38 - 00:41:42: allows us to iterate a set number of
00:41:41 - 00:41:44: times
00:41:42 - 00:41:45: so we will be talking about a while loop
00:41:44 - 00:41:47: the main difference between a while loop
00:41:45 - 00:41:47: and a for loop is a while loop is
00:41:47 - 00:41:49: running
00:41:47 - 00:41:50: an indefined amount of times we don't
00:41:49 - 00:41:52: know we're going based off of a
00:41:50 - 00:41:54: condition which we'll see shortly
00:41:52 - 00:41:56: a for loop we know how many times we're
00:41:54 - 00:41:57: going to loop at least relatively
00:41:56 - 00:41:58: so what i'm going to do is i'm actually
00:41:57 - 00:42:00: going to show you how we can just create
00:41:58 - 00:42:01: a basic for loop to print the numbers at
00:42:00 - 00:42:03: from 1 to 10.
00:42:01 - 00:42:05: say 4i in range and then inside of here
00:42:03 - 00:42:06: we simply put 10. i'll talk about what
00:42:05 - 00:42:08: this range function does in a second
00:42:06 - 00:42:10: but let me just show you how the for
00:42:08 - 00:42:11: loop actually operates so now i can show
00:42:10 - 00:42:14: you that this prints
00:42:11 - 00:42:16: 0 1 2 3 4 5 6 7 8 9
00:42:14 - 00:42:18: does not include 10. so the way we set
00:42:16 - 00:42:19: up a basic for loop if we're just going
00:42:18 - 00:42:22: to be iterating through account
00:42:19 - 00:42:24: is we say for i or for some variable
00:42:22 - 00:42:25: this is going to be our iterator or a
00:42:24 - 00:42:26: counter variable whatever you'd like to
00:42:25 - 00:42:28: call it
00:42:26 - 00:42:29: in this is a keyword we always have for
00:42:28 - 00:42:31: i in
00:42:29 - 00:42:32: and then some word here in this case
00:42:31 - 00:42:35: we're going to put range
00:42:32 - 00:42:36: range is a function that actually
00:42:35 - 00:42:38: creates a collection
00:42:36 - 00:42:40: of numbers based on the input that we
00:42:38 - 00:42:43: give it the input to range
00:42:40 - 00:42:46: is the following start
00:42:43 - 00:42:46: stop step so we're allowed to put up to
00:42:46 - 00:42:48: three
00:42:46 - 00:42:51: um and we can have less than three
00:42:48 - 00:42:52: arguments inside of this range function
00:42:51 - 00:42:54: essentially start stop step is saying
00:42:52 - 00:42:55: okay what number do we want to start at
00:42:54 - 00:42:56: what number do we stop at what number do
00:42:55 - 00:42:59: we step
00:42:56 - 00:43:01: at now if we only have one
00:42:59 - 00:43:03: argument so we only pass one number by
00:43:01 - 00:43:05: default that is the stop argument
00:43:03 - 00:43:07: we usually start at zero so by default
00:43:05 - 00:43:09: our range will start at zero
00:43:07 - 00:43:10: and we will go to whatever number we put
00:43:09 - 00:43:12: here most of the times you're just going
00:43:10 - 00:43:14: to put one number and this defines the
00:43:12 - 00:43:15: ending range so in this case it says
00:43:14 - 00:43:18: okay we're going to start at 0
00:43:15 - 00:43:20: and we're going to go up to 10 but not
00:43:18 - 00:43:21: include 10. notice we didn't print 10.
00:43:20 - 00:43:23: now if we had two arguments that's going
00:43:21 - 00:43:24: to be default start stop so we'll say
00:43:23 - 00:43:26: okay
00:43:24 - 00:43:28: we will start here at 1 and we'll stop
00:43:26 - 00:43:30: at 10 but not include 10.
00:43:28 - 00:43:31: if we add 3 we'll include a step and
00:43:30 - 00:43:33: that tells us how much we should
00:43:31 - 00:43:34: increment every single time by default
00:43:33 - 00:43:36: we increment by
00:43:34 - 00:43:38: 1 but we can increment by 2 and we can
00:43:36 - 00:43:41: increment by a negative number as well
00:43:38 - 00:43:42: let's actually say that we want to start
00:43:41 - 00:43:44: at 10
00:43:42 - 00:43:46: and we want it to go to negative 1 and
00:43:44 - 00:43:47: we want to step by negative 1.
00:43:46 - 00:43:49: well let's have a look at what this
00:43:47 - 00:43:51: looks like and just
00:43:49 - 00:43:52: test it out okay so running you see we
00:43:51 - 00:43:54: started at 10
00:43:52 - 00:43:56: right there and then we went all the way
00:43:54 - 00:43:57: down to zero and of course we could
00:43:56 - 00:43:59: start at negative 10
00:43:57 - 00:44:00: and watch what will happen here we do
00:43:59 - 00:44:02: nothing the reason for that is we
00:44:00 - 00:44:04: started at negative 10
00:44:02 - 00:44:05: we were going to negative 1 and we're
00:44:04 - 00:44:06: stepping by negative 1. but since we
00:44:05 - 00:44:08: were already past
00:44:06 - 00:44:09: negative one we aren't going to go there
00:44:08 - 00:44:11: obviously
00:44:09 - 00:44:13: and we just immediately stop so that is
00:44:11 - 00:44:16: kind of how the range function works so
00:44:13 - 00:44:18: for i in range again start stop step by
00:44:16 - 00:44:19: default if you just put one argument
00:44:18 - 00:44:21: that's going to be the stop if you put
00:44:19 - 00:44:22: two that's start stop
00:44:21 - 00:44:23: you can mess around with that and see
00:44:22 - 00:44:25: how it works but i think that's enough
00:44:23 - 00:44:26: of an explanation
00:44:25 - 00:44:27: the next thing we can do is actually
00:44:26 - 00:44:28: loop through a list so let's say we have
00:44:27 - 00:44:30: 4i
00:44:28 - 00:44:32: in and now instead of range we'll simply
00:44:30 - 00:44:34: just put a list we'll say 4i in range
00:44:32 - 00:44:35: and we can do 3 4 and just a bunch of
00:44:34 - 00:44:37: numbers here
00:44:35 - 00:44:39: now if we print i it will simply print
00:44:37 - 00:44:40: all of the numbers in that collection or
00:44:39 - 00:44:41: in that list it will step through one at
00:44:40 - 00:44:43: a time
00:44:41 - 00:44:45: and print all of them now let's say that
00:44:43 - 00:44:46: maybe we didn't want to do that
00:44:45 - 00:44:48: maybe we actually wanted to keep track
00:44:46 - 00:44:50: of what index we were at we could say x
00:44:48 - 00:44:53: equals the list we'd say 4i
00:44:50 - 00:44:54: in x and then um well sorry that
00:44:53 - 00:44:56: actually would not be the right way to
00:44:54 - 00:44:58: do we could say 4i in range
00:44:56 - 00:45:00: the len of x and then instead of just
00:44:58 - 00:45:02: printing i we could print
00:45:00 - 00:45:04: x square brackets i let's have a look at
00:45:02 - 00:45:05: this here you see how that works the way
00:45:04 - 00:45:07: this works is we're going to go up to
00:45:05 - 00:45:10: but not including the last index of
00:45:07 - 00:45:11: x or the length of x sorry so in this
00:45:10 - 00:45:14: case 1 2
00:45:11 - 00:45:16: 3 4 5 6. so this right here will say 6.
00:45:14 - 00:45:18: so for i in range 6 that means the
00:45:16 - 00:45:21: maximum value of i is going to be 5.
00:45:18 - 00:45:24: so we say x 0 x 1 x 2 3 4
00:45:21 - 00:45:25: 5 and print all of the values out now
00:45:24 - 00:45:27: there is another fancy thing that we can
00:45:25 - 00:45:29: do if we want to avoid using that it's
00:45:27 - 00:45:31: called enumerate
00:45:29 - 00:45:33: what enumerate will do is create indexes
00:45:31 - 00:45:35: and values for all of the
00:45:33 - 00:45:36: elements in our list so we'd say 4i
00:45:35 - 00:45:39: comma element
00:45:36 - 00:45:39: in enumerate x and then what i can do is
00:45:39 - 00:45:41: i
00:45:39 - 00:45:44: comma element and you'll see how this
00:45:41 - 00:45:46: works what we do is we get 0 1 2 3 4 5
00:45:44 - 00:45:48: and then all of the elements so this
00:45:46 - 00:45:49: works kind of like a combination of the
00:45:48 - 00:45:51: two for loop styles i just showed you
00:45:49 - 00:45:53: where we actually have a range so we go
00:45:51 - 00:45:55: from zero up to five those are all the
00:45:53 - 00:45:57: indexes in the list
00:45:55 - 00:45:58: and then we print all of the elements
00:45:57 - 00:46:00: for each of those indexes
00:45:58 - 00:46:02: in the list and we just have two
00:46:00 - 00:46:04: variables here that denote that
00:46:02 - 00:46:05: so the next topic to discuss is while
00:46:04 - 00:46:06: loops now while loops are pretty
00:46:05 - 00:46:08: straightforward essentially what they
00:46:06 - 00:46:11: are is while
00:46:08 - 00:46:13: condition equals equals true go ahead
00:46:11 - 00:46:14: and do something so we're going to have
00:46:13 - 00:46:16: some condition
00:46:14 - 00:46:17: here before this colon and then after
00:46:16 - 00:46:18: the colon there's going to be an
00:46:17 - 00:46:20: indented block and whatever's in that
00:46:18 - 00:46:21: indented block will run inside of the
00:46:20 - 00:46:22: loop
00:46:21 - 00:46:24: while that condition is true to
00:46:22 - 00:46:27: illustrate this i will say i
00:46:24 - 00:46:30: equals zero say while i is less than
00:46:27 - 00:46:33: 10 we'll say print run
00:46:30 - 00:46:35: and then we'll say i plus equals one
00:46:33 - 00:46:37: this is another way that you can add one
00:46:35 - 00:46:39: two variables so you could say i equals
00:46:37 - 00:46:40: i plus one or you can do i plus equals
00:46:39 - 00:46:42: one
00:46:40 - 00:46:45: you can also do something like i
00:46:42 - 00:46:46: multiplied equal by 1 or divided equal
00:46:45 - 00:46:47: by 1. so
00:46:46 - 00:46:49: multiplied by equal 2 what that's going
00:46:47 - 00:46:51: to do is say okay multiply i
00:46:49 - 00:46:53: by 2. we could do something like that if
00:46:51 - 00:46:54: we wanted as well just showing you
00:46:53 - 00:46:56: some more syntax for some interesting
00:46:54 - 00:46:58: things that we can do in python
00:46:56 - 00:46:59: but that's the basics of a while loop if
00:46:58 - 00:47:01: i go ahead and run this
00:46:59 - 00:47:03: we can see that this is going to run 10
00:47:01 - 00:47:05: times and there isn't really much more
00:47:03 - 00:47:06: to talk about for the while if other
00:47:05 - 00:47:07: than the fact that we can implement a
00:47:06 - 00:47:09: break statement
00:47:07 - 00:47:11: so we could also write the same code
00:47:09 - 00:47:14: like this while true
00:47:11 - 00:47:17: i plus equals 1 and then if i equals
00:47:14 - 00:47:19: equals 10 break and that will simply
00:47:17 - 00:47:21: break out of whatever the closest
00:47:19 - 00:47:22: loop is to us imagine we had another
00:47:21 - 00:47:23: while loop like this and we said while
00:47:22 - 00:47:27: true
00:47:23 - 00:47:30: inside of here then this would break
00:47:27 - 00:47:31: this while loop not the other while loop
00:47:30 - 00:47:33: hopefully that's making sense
00:47:31 - 00:47:35: anyways let's move on to the slice
00:47:33 - 00:47:38: operator so the slice operator is
00:47:35 - 00:47:39: personally my favorite part of python
00:47:38 - 00:47:41: there is implementations in other
00:47:39 - 00:47:43: languages but none of them are as nice
00:47:41 - 00:47:44: as python in my opinion
00:47:43 - 00:47:46: and what this allows us to do
00:47:44 - 00:47:49: essentially is to take a slice of a
00:47:46 - 00:47:50: collection like a string or a list or a
00:47:49 - 00:47:51: tuple
00:47:50 - 00:47:53: and do something with it so let me just
00:47:51 - 00:47:55: show you what i mean
00:47:53 - 00:47:57: the slice operator is simply the square
00:47:55 - 00:47:59: brackets like this with a sequence of
00:47:57 - 00:48:01: colons and numbers within it
00:47:59 - 00:48:02: the way that it works is we have a start
00:48:01 - 00:48:04: a stop
00:48:02 - 00:48:05: and a step just like the range function
00:48:04 - 00:48:08: that we looked at before
00:48:05 - 00:48:10: so if i put something like x here and
00:48:08 - 00:48:11: then i go start stop step
00:48:10 - 00:48:13: what i can do is say okay i want to
00:48:11 - 00:48:15: start at zero i want to
00:48:13 - 00:48:16: stop at index these are all indexes that
00:48:15 - 00:48:19: we're putting in here three
00:48:16 - 00:48:20: and i want to step by two now actually
00:48:19 - 00:48:22: let me just stop at index 4 just so we
00:48:20 - 00:48:23: get some more values in here but let me
00:48:22 - 00:48:26: show you what this looks like
00:48:23 - 00:48:27: we get the value 0 2 when i have 0 4 2
00:48:26 - 00:48:29: in my slice
00:48:27 - 00:48:31: what this is saying again is start at
00:48:29 - 00:48:33: the first index which is 0
00:48:31 - 00:48:35: go to the fourth index but do not
00:48:33 - 00:48:36: include it which means stop as soon as
00:48:35 - 00:48:38: we hit this and step by two
00:48:36 - 00:48:39: so we're gonna start at zero then we're
00:48:38 - 00:48:41: gonna go to two and then we're gonna go
00:48:39 - 00:48:43: to four but since four is the stop here
00:48:41 - 00:48:44: we're not going to include that in our
00:48:43 - 00:48:45: slice
00:48:44 - 00:48:47: now when we do the slice operator we
00:48:45 - 00:48:48: don't have to include all of these
00:48:47 - 00:48:50: different things as
00:48:48 - 00:48:52: arguments in fact what we can do is just
00:48:50 - 00:48:54: include a stop just include a start and
00:48:52 - 00:48:55: all of that so just like the range
00:48:54 - 00:48:57: function if we don't include
00:48:55 - 00:48:59: anything so we just sorry we just
00:48:57 - 00:49:01: include a colon like that and then we
00:48:59 - 00:49:03: put something on the right hand side
00:49:01 - 00:49:05: that is saying stop at whatever index we
00:49:03 - 00:49:07: put here so if we do this it says start
00:49:05 - 00:49:09: at the beginning and stop at the end now
00:49:07 - 00:49:12: if we do something like
00:49:09 - 00:49:14: 2 colon that says start at 2 and stop
00:49:12 - 00:49:15: at the end so whenever we leave a blank
00:49:14 - 00:49:17: we're assuming it's either the end or
00:49:15 - 00:49:19: the beginning or one in the case of a
00:49:17 - 00:49:22: step so if i did two colon colon
00:49:19 - 00:49:23: maybe i did two colon four colon this is
00:49:22 - 00:49:26: saying okay
00:49:23 - 00:49:26: start at two stop at four and then step
00:49:26 - 00:49:28: by one
00:49:26 - 00:49:30: but i don't even need to include that i
00:49:28 - 00:49:31: could just do two colon 4
00:49:30 - 00:49:34: but now let's say i wanted to go 4 and
00:49:31 - 00:49:36: then colon 2 colon negative 1
00:49:34 - 00:49:38: what this is saying is okay start at 4
00:49:36 - 00:49:39: go to 2 and step by negative 1. so now
00:49:38 - 00:49:40: what this is going to do is start at 4
00:49:39 - 00:49:43: which is actually this
00:49:40 - 00:49:44: and it's going to give us 4 and then
00:49:43 - 00:49:46: three and then it's not going to include
00:49:44 - 00:49:47: two or any of the other ones so that's
00:49:46 - 00:49:48: what we'll get in fact let's look at
00:49:47 - 00:49:50: this we see we get
00:49:48 - 00:49:52: four three now one of my favorite things
00:49:50 - 00:49:54: with a slice operator is to reverse a
00:49:52 - 00:49:54: list all we have to do is colon colon
00:49:54 - 00:49:56: negative one
00:49:54 - 00:49:58: this means start at the beginning stop
00:49:56 - 00:49:59: at the end and then step by
00:49:58 - 00:50:01: negative one so this will actually start
00:49:59 - 00:50:01: stepping backwards which is kind of
00:50:01 - 00:50:02: interesting
00:50:01 - 00:50:04: so when we look at that we get eight
00:50:02 - 00:50:07: seven six five four three two one zero
00:50:04 - 00:50:07: that is an easy way to reverse a list in
00:50:07 - 00:50:09: python
00:50:07 - 00:50:11: now of course all this works on a string
00:50:09 - 00:50:12: as well let me show you that with s
00:50:11 - 00:50:15: you see we can reverse the string like
00:50:12 - 00:50:16: that and we can also just do
00:50:15 - 00:50:18: the standard arguments that we would
00:50:16 - 00:50:20: typically do let maybe we'll just step
00:50:18 - 00:50:24: by two so start at the beginning stop
00:50:20 - 00:50:26: at the end and step by two we get hlo
00:50:24 - 00:50:27: so that's the basics of the slice
00:50:26 - 00:50:28: operator there's a bit more stuff that
00:50:27 - 00:50:30: we can do with this but
00:50:28 - 00:50:33: that is kind of how it works and i
00:50:30 - 00:50:34: believe this works on tuples as well
00:50:33 - 00:50:36: we can just try it out to make sure that
00:50:34 - 00:50:37: i'm not lying to you guys but if i do
00:50:36 - 00:50:39: that you can see
00:50:37 - 00:50:41: that that does indeed work and we can
00:50:39 - 00:50:43: use the slice on kind of any collection
00:50:41 - 00:50:45: of elements all right so now we are
00:50:43 - 00:50:47: moving on to sets which are an
00:50:45 - 00:50:48: underrated but extremely useful data
00:50:47 - 00:50:50: type in python
00:50:48 - 00:50:51: now a set is simply an unordered unique
00:50:50 - 00:50:53: collection of
00:50:51 - 00:50:54: elements what that means is there is no
00:50:53 - 00:50:57: duplicate elements we do not keep track
00:50:54 - 00:50:58: of order or frequency of elements
00:50:57 - 00:51:00: all we care about is if something is
00:50:58 - 00:51:02: there or if something is
00:51:00 - 00:51:04: not there the reason we do this is
00:51:02 - 00:51:06: because a set is extremely fast to do
00:51:04 - 00:51:07: what's called lookups removals or
00:51:06 - 00:51:08: additions when we're talking about a
00:51:07 - 00:51:10: list let's say we have something that
00:51:08 - 00:51:11: you know has a bunch of elements in it
00:51:10 - 00:51:13: if we want to say remove the first
00:51:11 - 00:51:14: element from the list that actually
00:51:13 - 00:51:16: involves shifting the position of all of
00:51:14 - 00:51:18: the other elements because we're keeping
00:51:16 - 00:51:20: track of the positions of these elements
00:51:18 - 00:51:21: with the set since there is no notion of
00:51:20 - 00:51:22: position adding and removing something
00:51:21 - 00:51:24: is as simple as just
00:51:22 - 00:51:26: adding or removing that element there's
00:51:24 - 00:51:28: no other operations that need to be done
00:51:26 - 00:51:29: which mean it's very fast to use so
00:51:28 - 00:51:31: think about a set to be used
00:51:29 - 00:51:33: only in a situation where you care if
00:51:31 - 00:51:35: something exists or doesn't exist
00:51:33 - 00:51:37: not about the frequency or order in
00:51:35 - 00:51:38: which that item exists
00:51:37 - 00:51:40: so to create a set is pretty
00:51:38 - 00:51:42: straightforward we can say x equals set
00:51:40 - 00:51:43: and we use the open bracket and close
00:51:42 - 00:51:45: bracket
00:51:43 - 00:51:46: now the reason we don't actually write
00:51:45 - 00:51:48: something like say s
00:51:46 - 00:51:49: equals and then this which is really the
00:51:48 - 00:51:51: representation for a set
00:51:49 - 00:51:52: is because what this will do is create a
00:51:51 - 00:51:54: dictionary
00:51:52 - 00:51:56: now technically if we want to create a
00:51:54 - 00:51:57: set we can do something like this
00:51:56 - 00:51:59: and this will create a set for us that
00:51:57 - 00:52:01: initially has the elements 4 32
00:51:59 - 00:52:03: and 2 inside of it this is what's known
00:52:01 - 00:52:04: as a set literal
00:52:03 - 00:52:06: if you're not going to be creating an
00:52:04 - 00:52:07: empty set it's totally fine to do it
00:52:06 - 00:52:08: like this so long as you add an element
00:52:07 - 00:52:09: inside
00:52:08 - 00:52:11: but if you are creating an empty set
00:52:09 - 00:52:12: then you need to use this constructor
00:52:11 - 00:52:13: otherwise you're going to end up
00:52:12 - 00:52:14: creating a dictionary which is not what
00:52:13 - 00:52:16: you want
00:52:14 - 00:52:18: to prove the simple point to you i will
00:52:16 - 00:52:20: print out the type of just an empty
00:52:18 - 00:52:22: you know set representation and you'll
00:52:20 - 00:52:23: see that it gives me dict like that
00:52:22 - 00:52:25: of course that's not what we want
00:52:23 - 00:52:26: anyways let's have a look at this set
00:52:25 - 00:52:28: and i'll just show you what i mean by
00:52:26 - 00:52:30: unique unordered collection of elements
00:52:28 - 00:52:32: so 4322
00:52:30 - 00:52:34: if we print that out we get 32 to 4 so
00:52:32 - 00:52:35: obviously a different order than how we
00:52:34 - 00:52:36: added in there
00:52:35 - 00:52:38: and notice that the duplicate twos were
00:52:36 - 00:52:39: removed now the set operations are
00:52:38 - 00:52:40: pretty straightforward we can add
00:52:39 - 00:52:43: something to a set with
00:52:40 - 00:52:44: s dot add our set dot add i'll put five
00:52:43 - 00:52:46: and
00:52:44 - 00:52:48: inside of here and let's just keep
00:52:46 - 00:52:48: printing out s there we go we can see we
00:52:48 - 00:52:52: added in there
00:52:48 - 00:52:54: we can also do s dot remove 5
00:52:52 - 00:52:56: and that will well since there's nothing
00:52:54 - 00:52:58: in there give us a key error now if
00:52:56 - 00:52:59: there is the element in there so we can
00:52:58 - 00:53:01: do it like this it will remove that
00:52:59 - 00:53:02: element for us and then there's a few
00:53:01 - 00:53:03: other things that we can do as well for
00:53:02 - 00:53:04: a set
00:53:03 - 00:53:06: one of the good ones is actually
00:53:04 - 00:53:09: checking if something is in a set
00:53:06 - 00:53:11: what i can do is say 4 in s what this
00:53:09 - 00:53:13: will do is simply check if the element 4
00:53:11 - 00:53:15: is in the set and give me a true or
00:53:13 - 00:53:16: false in this case it is true
00:53:15 - 00:53:17: and remember this happens in what's
00:53:16 - 00:53:19: known as constant time which means it's
00:53:17 - 00:53:22: just extremely fast to do this
00:53:19 - 00:53:24: as opposed to a list so we could say 33
00:53:22 - 00:53:25: in s that's going to give me false
00:53:24 - 00:53:27: now the parallel i want to make here is
00:53:25 - 00:53:31: if i had s
00:53:27 - 00:53:34: equals to 4 32 2 2
00:53:31 - 00:53:35: like that so actually let's go s2 and i
00:53:34 - 00:53:39: said print
00:53:35 - 00:53:40: and let's just go 2 in s2
00:53:39 - 00:53:42: this operation the one that's actually
00:53:40 - 00:53:45: in the set is going to happen
00:53:42 - 00:53:45: much much much much much faster than
00:53:45 - 00:53:46: this one
00:53:45 - 00:53:48: of course this isn't a big deal right
00:53:46 - 00:53:50: now because these collections are quite
00:53:48 - 00:53:52: small but as these get
00:53:50 - 00:53:53: extremely large just understand that
00:53:52 - 00:53:55: using a set is very beneficial when it
00:53:53 - 00:53:56: comes to looking things up
00:53:55 - 00:53:57: checking if something's in there
00:53:56 - 00:53:59: removing and deleting there's a few
00:53:57 - 00:54:01: other operations we can do on sets
00:53:59 - 00:54:03: let me just define s2 and i'll just
00:54:01 - 00:54:05: quickly show you a few of them
00:54:03 - 00:54:07: we can do for example the intersection
00:54:05 - 00:54:09: or the union of these sets so i can say
00:54:07 - 00:54:10: s dot union s2
00:54:09 - 00:54:11: and we'll go ahead and have a look here
00:54:10 - 00:54:13: and we can see we get the union of these
00:54:11 - 00:54:13: two sets essentially adding them
00:54:13 - 00:54:16: together
00:54:13 - 00:54:17: we can do the difference of the two sets
00:54:16 - 00:54:19: if we want
00:54:17 - 00:54:21: we can do the intersection and we can do
00:54:19 - 00:54:22: the symmetric difference and all that
00:54:21 - 00:54:24: other fun stuff that you can do
00:54:22 - 00:54:26: with sets now i'm not going to get into
00:54:24 - 00:54:27: all that stuff just know that these are
00:54:26 - 00:54:28: sets and that's some of the stuff that
00:54:27 - 00:54:30: you can do with them
00:54:28 - 00:54:31: so now i'm going to talk about
00:54:30 - 00:54:33: dictionaries now if you're from another
00:54:31 - 00:54:35: language what may be familiar to you
00:54:33 - 00:54:36: here is a hash table or a map
00:54:35 - 00:54:37: something like that they're very similar
00:54:36 - 00:54:39: to dictionaries but a dictionary is
00:54:37 - 00:54:41: essentially a key value pair
00:54:39 - 00:54:42: you have some key you have a colon and
00:54:41 - 00:54:44: then you have some value that it
00:54:42 - 00:54:46: corresponds to now of course that value
00:54:44 - 00:54:48: has to actually be a valid data type
00:54:46 - 00:54:50: but it could be something like a list it
00:54:48 - 00:54:52: could be a single value like that
00:54:50 - 00:54:54: and the way that you access and create
00:54:52 - 00:54:57: new key value pairs is
00:54:54 - 00:54:59: something like this i can print out say
00:54:57 - 00:55:00: x and then the key inside of here in
00:54:59 - 00:55:02: this case it's actually called key
00:55:00 - 00:55:04: and what that will give me if you look
00:55:02 - 00:55:06: down here is simply the value 4 because
00:55:04 - 00:55:08: well that's what corresponds
00:55:06 - 00:55:10: to this key so you have keys and you
00:55:08 - 00:55:11: have values now to add a new key is
00:55:10 - 00:55:12: pretty straightforward what you can do
00:55:11 - 00:55:14: is you can say x
00:55:12 - 00:55:16: inside of square brackets you can define
00:55:14 - 00:55:17: whatever key you like it can already
00:55:16 - 00:55:18: exist if you want
00:55:17 - 00:55:20: we can say something like key2 and we
00:55:18 - 00:55:22: can make that equal to 5.
00:55:20 - 00:55:24: now note that these keys do not need to
00:55:22 - 00:55:25: be the same
00:55:24 - 00:55:27: sorry same data type so i don't have to
00:55:25 - 00:55:29: have two string keys i can have integer
00:55:27 - 00:55:33: keys i can have whatever keys i want
00:55:29 - 00:55:35: do something like x2 equals 8 and there
00:55:33 - 00:55:37: we go you see that works perfectly fine
00:55:35 - 00:55:38: in fact i can make this a list just to
00:55:37 - 00:55:40: prove to you that the values don't have
00:55:38 - 00:55:42: to be the same either and
00:55:40 - 00:55:44: there you go now just like a set this
00:55:42 - 00:55:45: actually works using a hash which means
00:55:44 - 00:55:48: this is very fast
00:55:45 - 00:55:49: to retrieve add and modify values within
00:55:48 - 00:55:51: the dictionary
00:55:49 - 00:55:52: in fact it's so fast you can kind of
00:55:51 - 00:55:54: assume that it's in constant time
00:55:52 - 00:55:56: although there is a chance there will be
00:55:54 - 00:55:57: something known as hash collisions
00:55:56 - 00:55:58: although i'm not going to talk about
00:55:57 - 00:56:00: that because that's probably a little
00:55:58 - 00:56:00: bit more advanced than what most of you
00:56:00 - 00:56:02: know
00:56:00 - 00:56:04: anyways what we can do here in terms of
00:56:02 - 00:56:06: operations on the dictionaries we can
00:56:04 - 00:56:07: check if something is in the dictionary
00:56:06 - 00:56:08: so i can say okay is some key in the
00:56:07 - 00:56:11: dictionary
00:56:08 - 00:56:13: key in x there we go print that out and
00:56:11 - 00:56:14: that says true
00:56:13 - 00:56:15: a few other useful things that we can do
00:56:14 - 00:56:16: is we can get all the values from the
00:56:15 - 00:56:18: dictionary
00:56:16 - 00:56:20: so we can say x dot values print that
00:56:18 - 00:56:22: out and it says addict values and it
00:56:20 - 00:56:23: gives us a list of four
00:56:22 - 00:56:25: usually when you do this you're going to
00:56:23 - 00:56:27: want to actually create a list out of
00:56:25 - 00:56:28: this because that is a different data
00:56:27 - 00:56:30: type that's returning to us
00:56:28 - 00:56:32: and there you go we get the value 4. now
00:56:30 - 00:56:35: similarly we can do
00:56:32 - 00:56:38: dick.keys so x dot keys and there we go
00:56:35 - 00:56:40: we get a list that has all of the keys
00:56:38 - 00:56:41: in terms of iterating over or deleting
00:56:40 - 00:56:43: values i'll first show you how you
00:56:41 - 00:56:43: delete something to delete something we
00:56:43 - 00:56:45: can say
00:56:43 - 00:56:47: x and then the key that we want to
00:56:45 - 00:56:49: remove in this case it will remove
00:56:47 - 00:56:51: this key so let's go ahead and do that
00:56:49 - 00:56:52: and well i guess
00:56:51 - 00:56:53: it didn't really show you that it was
00:56:52 - 00:56:54: deleted let's just print it out to prove
00:56:53 - 00:56:56: that
00:56:54 - 00:56:57: there you go and we get an empty
00:56:56 - 00:56:58: dictionary of course
00:56:57 - 00:57:00: like i showed you before we can use that
00:56:58 - 00:57:02: in operator and to loop over it there's
00:57:00 - 00:57:03: actually a few interesting ways that we
00:57:02 - 00:57:06: can do this so i can say
00:57:03 - 00:57:09: for a key value
00:57:06 - 00:57:11: in x dot items and then what this will
00:57:09 - 00:57:12: do is simply return to me all the keys
00:57:11 - 00:57:14: and values
00:57:12 - 00:57:16: so i can print key value and you'll see
00:57:14 - 00:57:18: we'll get key
00:57:16 - 00:57:19: four so if i want to loop through all
00:57:18 - 00:57:21: the keys and all of the values i can use
00:57:19 - 00:57:23: dot items if i don't want to do that i
00:57:21 - 00:57:24: can just say four key and then i can say
00:57:23 - 00:57:25: in x
00:57:24 - 00:57:27: what this will do is simply just give me
00:57:25 - 00:57:29: all the keys in x and if i want to
00:57:27 - 00:57:31: access the value of course i could say
00:57:29 - 00:57:33: x key like that and that will give me
00:57:31 - 00:57:34: the value and we get the same thing
00:57:33 - 00:57:35: popping up there
00:57:34 - 00:57:36: that's kind of the basics for the
00:57:35 - 00:57:38: dictionaries there's a few other methods
00:57:36 - 00:57:40: as well but i'm not going to talk about
00:57:38 - 00:57:43: those um that is a dictionary
00:57:40 - 00:57:44: and this next one is a fun one this is
00:57:43 - 00:57:45: comprehensions
00:57:44 - 00:57:47: now as far as i know python is one of
00:57:45 - 00:57:48: the only programming languages that
00:57:47 - 00:57:51: actually has this a lot of people
00:57:48 - 00:57:51: absolutely hate it but i personally love
00:57:51 - 00:57:53: it
00:57:51 - 00:57:55: and if you learn to love it you can use
00:57:53 - 00:57:57: it quite well now to do a comprehension
00:57:55 - 00:58:00: essentially what that is is a one
00:57:57 - 00:58:02: line initialization of a list of a tuple
00:58:00 - 00:58:03: of a dictionary of many other things so
00:58:02 - 00:58:04: let me just show you what i mean i can
00:58:03 - 00:58:06: do something like
00:58:04 - 00:58:07: x equals a list and then i can say x for
00:58:06 - 00:58:10: x
00:58:07 - 00:58:13: in range five now if i go ahead and i
00:58:10 - 00:58:15: print the value of x you're going to see
00:58:13 - 00:58:17: what we get here
00:58:15 - 00:58:18: let's run it like that we get zero one
00:58:17 - 00:58:20: two three four
00:58:18 - 00:58:22: the way this works is essentially we can
00:58:20 - 00:58:24: actually define a for loop inside of
00:58:22 - 00:58:25: this list and what it will do is say
00:58:24 - 00:58:26: okay we're going to loop through as if
00:58:25 - 00:58:28: we normally would
00:58:26 - 00:58:30: and whatever we have on the left hand
00:58:28 - 00:58:31: side here is actually the element that
00:58:30 - 00:58:33: we're going to add into the list
00:58:31 - 00:58:35: so i could do something like x plus 5
00:58:33 - 00:58:36: for x in range
00:58:35 - 00:58:38: five and there we go we get five six
00:58:36 - 00:58:40: seven eight nine ten i can also do
00:58:38 - 00:58:43: something like you know x
00:58:40 - 00:58:45: mod two and or x mod five there we go
00:58:43 - 00:58:47: i can also you know grab something else
00:58:45 - 00:58:49: i could say zero for x in range five
00:58:47 - 00:58:50: that would give me a list of all zeros
00:58:49 - 00:58:51: you can see how this might actually be
00:58:50 - 00:58:53: useful
00:58:51 - 00:58:55: now if we want to go into a more complex
00:58:53 - 00:58:57: example i could do a list and then
00:58:55 - 00:59:00: inside this list i could say
00:58:57 - 00:59:04: 0 for x in range
00:59:00 - 00:59:06: 100 for x in
00:59:04 - 00:59:08: range five now what that's going to give
00:59:06 - 00:59:10: us is five of these lists that each have
00:59:08 - 00:59:12: a hundred zeros inside of them you can
00:59:10 - 00:59:14: see that's quite large
00:59:12 - 00:59:15: but that is kind of how that works now
00:59:14 - 00:59:17: we can also go ahead and add some more
00:59:15 - 00:59:20: complex stuff to this too
00:59:17 - 00:59:25: we and say 0 for or i can say
00:59:20 - 00:59:28: i for i in range 100
00:59:25 - 00:59:29: if i mod 5 equals equals 0. so
00:59:28 - 00:59:32: essentially if
00:59:29 - 00:59:33: if i is divisible by five then what we
00:59:32 - 00:59:34: can do is actually add it into the list
00:59:33 - 00:59:37: let's have a look at that and there we
00:59:34 - 00:59:38: go we get all the increments of five
00:59:37 - 00:59:39: so you can play around with that and see
00:59:38 - 00:59:41: how that works but this also works for
00:59:39 - 00:59:42: dictionaries in fact let's just do the
00:59:41 - 00:59:43: same thing here let's make it a
00:59:42 - 00:59:46: dictionary
00:59:43 - 00:59:47: and now we'll just go i colon zero so we
00:59:46 - 00:59:48: have all these keys that are initialized
00:59:47 - 00:59:49: at zero
00:59:48 - 00:59:51: we go there and have a look we can see
00:59:49 - 00:59:52: that dictionary works and of course we
00:59:51 - 00:59:54: could
00:59:52 - 00:59:56: do the same thing for a set we can just
00:59:54 - 00:59:58: say i for i in range blah blah
00:59:56 - 00:59:59: and there we go now we get a set so we
00:59:58 - 01:00:00: can actually do this for tuples as well
00:59:59 - 01:00:02: except we're not going to do it in the
01:00:00 - 01:00:04: way that you might assume
01:00:02 - 01:00:05: if you just go ahead and do this this
01:00:04 - 01:00:06: actually returns to us what's known as a
01:00:05 - 01:00:08: generator object
01:00:06 - 01:00:09: it's a bit more advanced for this kind
01:00:08 - 01:00:10: of video so i'm not going to talk about
01:00:09 - 01:00:12: that but what we can do if we want to
01:00:10 - 01:00:14: make this work for tuple is we actually
01:00:12 - 01:00:15: type tuple we can use the tuple
01:00:14 - 01:00:17: constructor which is simply this and
01:00:15 - 01:00:18: then do the comprehension inside of
01:00:17 - 01:00:20: there now that will return to us the
01:00:18 - 01:00:21: tuple you can see i tried to do it the
01:00:20 - 01:00:23: other way before and that returned to me
01:00:21 - 01:00:24: the generator object
01:00:23 - 01:00:26: anyways that is comprehension these can
01:00:24 - 01:00:28: be used in a whack of different things
01:00:26 - 01:00:29: they're definitely interesting and good
01:00:28 - 01:00:31: to know and one of the best features of
01:00:29 - 01:00:32: python that is not in
01:00:31 - 01:00:34: many other languages so now i'm going to
01:00:32 - 01:00:35: start talking about functions so to
01:00:34 - 01:00:38: define a function in python you simply
01:00:35 - 01:00:39: use the def keyword this means define
01:00:38 - 01:00:40: then you pick your function name in this
01:00:39 - 01:00:42: case i'm going to pick func the function
01:00:40 - 01:00:43: names are the same as variable
01:00:42 - 01:00:45: names in terms of how you name them you
01:00:43 - 01:00:46: can put some positional
01:00:45 - 01:00:48: parameters inside of here if you want or
01:00:46 - 01:00:49: you can leave it empty you add a colon
01:00:48 - 01:00:51: indented block
01:00:49 - 01:00:52: then anything inside of the indent will
01:00:51 - 01:00:54: run when you run the function so let's
01:00:52 - 01:00:56: go ahead and actually just run this
01:00:54 - 01:00:58: and show you the basics of this so that
01:00:56 - 01:00:58: is pretty much how you run and define a
01:00:58 - 01:01:00: function
01:00:58 - 01:01:01: of course you can define multiple
01:01:00 - 01:01:02: functions you can actually define
01:01:01 - 01:01:04: functions
01:01:02 - 01:01:06: inside of functions if you wanted to
01:01:04 - 01:01:08: this is totally valid
01:01:06 - 01:01:09: if i wanted to do something like this
01:01:08 - 01:01:10: and
01:01:09 - 01:01:12: then i could call funk like that now of
01:01:10 - 01:01:13: course this is a more advanced use case
01:01:12 - 01:01:15: but just showing that you can do that
01:01:13 - 01:01:17: because of the way that python works
01:01:15 - 01:01:18: in fact functions are actually objects
01:01:17 - 01:01:20: which means you can technically return
01:01:18 - 01:01:22: them i'll show that in a second but
01:01:20 - 01:01:24: let me talk about arguments first so
01:01:22 - 01:01:26: let's say i want to add the argument x y
01:01:24 - 01:01:27: inside of here of course that means now
01:01:26 - 01:01:28: when i call the function i need to add
01:01:27 - 01:01:31: some value for
01:01:28 - 01:01:32: x and for y so let's go five six and now
01:01:31 - 01:01:33: if i
01:01:32 - 01:01:35: after run want to print those i can
01:01:33 - 01:01:38: print x and i can print y
01:01:35 - 01:01:39: let's have a quick look we get run 5 6.
01:01:38 - 01:01:41: of course we can return something from a
01:01:39 - 01:01:43: function as well maybe i'll return
01:01:41 - 01:01:44: x multiplied by y now if we actually go
01:01:43 - 01:01:46: ahead and print
01:01:44 - 01:01:48: the value of this function what will
01:01:46 - 01:01:50: happen is it will evaluate what is here
01:01:48 - 01:01:52: return that to us and print that out we
01:01:50 - 01:01:54: get the value 30. now note that when you
01:01:52 - 01:01:56: return multiple things from a function
01:01:54 - 01:01:58: which you can do i can return x
01:01:56 - 01:02:00: multiplied by y and maybe x divided by y
01:01:58 - 01:02:01: as well this will return the value to us
01:02:00 - 01:02:03: in
01:02:01 - 01:02:04: a tuple so if you look here we get
01:02:03 - 01:02:06: actually two values we have i guess the
01:02:04 - 01:02:08: x y value here
01:02:06 - 01:02:10: and that's inside of a tuple now if we
01:02:08 - 01:02:11: want to unpack this tuple and say
01:02:10 - 01:02:12: separate this out into different
01:02:11 - 01:02:14: variables
01:02:12 - 01:02:15: we could of course index at zero and
01:02:14 - 01:02:17: index at one but a much cleaner and
01:02:15 - 01:02:20: faster way to do this
01:02:17 - 01:02:21: is to do something like r1 comma r2
01:02:20 - 01:02:22: equals func 5
01:02:21 - 01:02:24: 6. what this is going to do is take
01:02:22 - 01:02:26: these two values here and simply
01:02:24 - 01:02:27: separate them into the r1 and r2
01:02:26 - 01:02:29: variable
01:02:27 - 01:02:31: now if i go ahead and i print r1 r2 and
01:02:29 - 01:02:34: i have a look here you can see that we
01:02:31 - 01:02:36: get 30 and then 0.83334
01:02:34 - 01:02:37: that is the basis for a function if you
01:02:36 - 01:02:38: want to do a
01:02:37 - 01:02:40: optional parameter you can do something
01:02:38 - 01:02:42: like z equals you can set a default
01:02:40 - 01:02:43: value i usually set it as
01:02:42 - 01:02:45: none and what this means is that you do
01:02:43 - 01:02:46: not have to pass that in but if you want
01:02:45 - 01:02:48: to you may
01:02:46 - 01:02:50: and it will override the optional value
01:02:48 - 01:02:51: that you have here so let's just start
01:02:50 - 01:02:53: by actually printing out zed
01:02:51 - 01:02:55: i'm not going to call it with zed to
01:02:53 - 01:02:58: start you can see
01:02:55 - 01:02:59: that oops let's run that for a second we
01:02:58 - 01:03:01: get run five six
01:02:59 - 01:03:03: none and now if i add a z so let's just
01:03:01 - 01:03:05: add seven there we see that instead of
01:03:03 - 01:03:06: none we are going to get seven printing
01:03:05 - 01:03:08: out right there
01:03:06 - 01:03:09: that is the basics of a function and now
01:03:08 - 01:03:12: we're going to move on to some other
01:03:09 - 01:03:13: more advanced aspects of it
01:03:12 - 01:03:14: all right so i'm going to talk about
01:03:13 - 01:03:15: something that's really cool called the
01:03:14 - 01:03:17: unpack operator and then i'm going to
01:03:15 - 01:03:19: talk about star args and star star
01:03:17 - 01:03:20: quarks but i first want to show you an
01:03:19 - 01:03:22: advanced example of a function
01:03:20 - 01:03:24: so if i say define func like this and
01:03:22 - 01:03:26: then maybe i'll say take x and i define
01:03:24 - 01:03:28: func 2 inside of here this is totally
01:03:26 - 01:03:29: valid by the way you can put a function
01:03:28 - 01:03:30: inside of another function
01:03:29 - 01:03:31: and then inside of here what i'm
01:03:30 - 01:03:33: actually going to do is say this
01:03:31 - 01:03:35: function is going to print x
01:03:33 - 01:03:37: and i'm going to return func 2 but
01:03:35 - 01:03:38: notice i don't call it
01:03:37 - 01:03:39: now this is just to prove to you that
01:03:38 - 01:03:41: functions are objects hence they can be
01:03:39 - 01:03:42: passed around just like variables
01:03:41 - 01:03:44: so what i can actually do here is i can
01:03:42 - 01:03:47: go ahead and i can say print
01:03:44 - 01:03:49: or sorry not print but i can call func 4
01:03:47 - 01:03:51: or func 3 and then i can actually call
01:03:49 - 01:03:52: it like this what this is doing
01:03:51 - 01:03:54: essentially is saying okay i'm going to
01:03:52 - 01:03:54: call this function here with the value
01:03:54 - 01:03:56: 3.
01:03:54 - 01:03:58: what this function does is it returns to
01:03:56 - 01:04:00: me another function
01:03:58 - 01:04:01: so it gives me func 2. notice it's not
01:04:00 - 01:04:02: calling the function it's simply
01:04:01 - 01:04:03: returning it
01:04:02 - 01:04:05: now i'll actually just show you what i
01:04:03 - 01:04:07: mean first before confusing anyone let's
01:04:05 - 01:04:08: print this out before i do the call
01:04:07 - 01:04:09: statement on it
01:04:08 - 01:04:11: but you can see that this actually tells
01:04:09 - 01:04:13: me this is a function object it's a
01:04:11 - 01:04:13: func.local's func 2. so it's pretty much
01:04:13 - 01:04:16: saying that
01:04:13 - 01:04:17: funct2 is defined within func now if i
01:04:16 - 01:04:18: actually call this because that's just
01:04:17 - 01:04:20: the function
01:04:18 - 01:04:22: reference or object it's not actually
01:04:20 - 01:04:23: you know being evaluated if i call it
01:04:22 - 01:04:25: like that
01:04:23 - 01:04:27: we can go ahead and we get 3 and then we
01:04:25 - 01:04:28: get none of course the print statement
01:04:27 - 01:04:30: is going to print none because
01:04:28 - 01:04:31: there is no there's nothing to print
01:04:30 - 01:04:34: from the return of func
01:04:31 - 01:04:35: 2 but just have a look here we get 3.
01:04:34 - 01:04:36: now this is equivalent if i did
01:04:35 - 01:04:40: something like this i said you know
01:04:36 - 01:04:41: x equals func and then on the next line
01:04:40 - 01:04:43: i just called x
01:04:41 - 01:04:44: since x is equal to a function func two
01:04:43 - 01:04:46: i can call it just like i showed you
01:04:44 - 01:04:48: before and there we go we get three
01:04:46 - 01:04:49: anyways that's the advanced aspect i
01:04:48 - 01:04:50: wanted to show now what i want to do is
01:04:49 - 01:04:51: show you about star args and star star
01:04:50 - 01:04:54: quarks
01:04:51 - 01:04:56: uh so i'm going to put in like this all
01:04:54 - 01:04:57: right so before i define what this does
01:04:56 - 01:04:59: what i'm going to do is just show you
01:04:57 - 01:05:00: what the unpack operator is in python so
01:04:59 - 01:05:01: let's say i have a list maybe we'll call
01:05:00 - 01:05:04: it x
01:05:01 - 01:05:07: and we just have a bunch oops of
01:05:04 - 01:05:09: random numbers in this list so what the
01:05:07 - 01:05:11: unpack operator does is actually
01:05:09 - 01:05:12: separate all of the elements from a list
01:05:11 - 01:05:13: or from a collection into individual
01:05:12 - 01:05:14: elements
01:05:13 - 01:05:16: the best example of this is the print
01:05:14 - 01:05:17: statement if i print asterisk x which
01:05:16 - 01:05:19: means unpack
01:05:17 - 01:05:21: x what this is going to do is take all
01:05:19 - 01:05:22: of these elements out so separate them
01:05:21 - 01:05:24: by individual elements and pass them
01:05:22 - 01:05:26: into the print statement as arguments
01:05:24 - 01:05:28: so instead of just printing you know say
01:05:26 - 01:05:29: the entire list what it's actually gonna
01:05:28 - 01:05:32: look like is print
01:05:29 - 01:05:34: one comma two three comma two three six
01:05:32 - 01:05:36: blah blah you get the point
01:05:34 - 01:05:37: that is what this is going to do so just
01:05:36 - 01:05:37: have a look at what happens when i print
01:05:37 - 01:05:39: that
01:05:37 - 01:05:41: i get all of these things separated by
01:05:39 - 01:05:42: spaces like what happened if i just pass
01:05:41 - 01:05:43: them in individually not being in the
01:05:42 - 01:05:44: list
01:05:43 - 01:05:46: now look what happens when i just print
01:05:44 - 01:05:49: x let's have a look
01:05:46 - 01:05:50: see it actually prints the list out so
01:05:49 - 01:05:52: what this does is
01:05:50 - 01:05:54: unpack whatever we have in a tuple or a
01:05:52 - 01:05:56: list or some kind of collection
01:05:54 - 01:05:57: and sends it through as arguments to a
01:05:56 - 01:05:59: function so that's where star
01:05:57 - 01:06:01: args and star star quarks come in
01:05:59 - 01:06:02: although you'll see that in one second
01:06:01 - 01:06:04: so let's say i have
01:06:02 - 01:06:05: you know x y that we need inside of a
01:06:04 - 01:06:10: function we got to pass x
01:06:05 - 01:06:12: y what this will do is simply print
01:06:10 - 01:06:13: x and then print y now let's say i
01:06:12 - 01:06:14: actually have
01:06:13 - 01:06:17: maybe a bunch of pairs that i want to
01:06:14 - 01:06:20: pass this function so maybe i say pairs
01:06:17 - 01:06:21: equals and then i have like one two
01:06:20 - 01:06:23: three four well what i'm going to do is
01:06:21 - 01:06:25: do a for looping and say four pair
01:06:23 - 01:06:27: in pairs and what i want to do is call
01:06:25 - 01:06:28: this function with those pairs
01:06:27 - 01:06:31: now the naive way to do this would be to
01:06:28 - 01:06:34: go func okay pair
01:06:31 - 01:06:35: and then pair 1. great that would work
01:06:34 - 01:06:37: but that is not
01:06:35 - 01:06:38: the pythonic way to do this what we can
01:06:37 - 01:06:41: actually do is do asterix pair
01:06:38 - 01:06:43: and what this will do is take 1 2 and
01:06:41 - 01:06:44: take 3 4 unpack them separate them and
01:06:43 - 01:06:45: pass them as arguments to funk
01:06:44 - 01:06:47: so if you have a look at that that
01:06:45 - 01:06:48: actually works and that is why the
01:06:47 - 01:06:50: unpack operator is really useful
01:06:48 - 01:06:52: you can also use this actually on
01:06:50 - 01:06:53: dictionaries as well and i'll show you
01:06:52 - 01:06:55: how it works with dictionaries a little
01:06:53 - 01:06:55: bit more complicated it involves two
01:06:55 - 01:06:57: asterisks
01:06:55 - 01:06:59: what this does is if i have keys i can
01:06:57 - 01:07:00: say x representing obviously the
01:06:59 - 01:07:02: argument
01:07:00 - 01:07:03: x and then make that equal to 2 and then
01:07:02 - 01:07:05: i can say y and this could represent the
01:07:03 - 01:07:06: argument y
01:07:05 - 01:07:08: and i'll make that equal to 5. now if i
01:07:06 - 01:07:10: run this this works fine i needed two
01:07:08 - 01:07:13: asterisks because this was a dictionary
01:07:10 - 01:07:14: and that is kind of how this works um
01:07:13 - 01:07:15: yeah i don't
01:07:14 - 01:07:17: i guess i really need the for loop
01:07:15 - 01:07:19: anymore to illustrate this
01:07:17 - 01:07:20: but the double asterisk is used for
01:07:19 - 01:07:22: dictionaries the single asterisk is used
01:07:20 - 01:07:23: for a tuple or for a list
01:07:22 - 01:07:25: now i just want to make the point here
01:07:23 - 01:07:26: that let's say these are not in the
01:07:25 - 01:07:29: correct order so it's
01:07:26 - 01:07:30: y and then x this will still work and
01:07:29 - 01:07:31: that's actually why this is really
01:07:30 - 01:07:32: useful because you don't have to have it
01:07:31 - 01:07:34: in the correct order
01:07:32 - 01:07:36: so long as you name the arguments as the
01:07:34 - 01:07:39: keys so now hopefully that will explain
01:07:36 - 01:07:42: to us how star args and star quarks work
01:07:39 - 01:07:43: so star args and star star quarks
01:07:42 - 01:07:45: essentially imagine you have a function
01:07:43 - 01:07:47: you don't know how many arguments
01:07:45 - 01:07:48: positional or keyword arguments you want
01:07:47 - 01:07:50: to accept that's what quark stands for
01:07:48 - 01:07:51: keyword arguments
01:07:50 - 01:07:53: well what you can do is you can use star
01:07:51 - 01:07:55: args and star star quarks
01:07:53 - 01:07:56: and what that will do is allow you to
01:07:55 - 01:07:58: pass in an unlimited amount of regular
01:07:56 - 01:08:01: arguments and keyword arguments
01:07:58 - 01:08:03: so if i actually go ahead and go funk
01:08:01 - 01:08:04: and then i pass like one two three four
01:08:03 - 01:08:05: five
01:08:04 - 01:08:07: and maybe i'll pass some keyword
01:08:05 - 01:08:10: arguments like you know one
01:08:07 - 01:08:11: equals zero two equals 1. i know this
01:08:10 - 01:08:12: doesn't really make any sense but you
01:08:11 - 01:08:14: get the idea
01:08:12 - 01:08:15: now if i actually run this and print it
01:08:14 - 01:08:16: out you can see that when i print args
01:08:15 - 01:08:18: and print quarks
01:08:16 - 01:08:20: we're getting a tuple that has all of
01:08:18 - 01:08:22: the positional arguments which are these
01:08:20 - 01:08:23: and all of the keyword arguments which
01:08:22 - 01:08:26: are 1 and two
01:08:23 - 01:08:28: now if i wanted to actually use any of
01:08:26 - 01:08:30: these what i can do is i can unpack them
01:08:28 - 01:08:32: so first of all i can unpack args and
01:08:30 - 01:08:33: what this does if we have a look here is
01:08:32 - 01:08:34: it will print out one two three four
01:08:33 - 01:08:36: five
01:08:34 - 01:08:38: i could try to unpack quarks but you're
01:08:36 - 01:08:39: going to see what happens when i do this
01:08:38 - 01:08:41: and hopefully if you remember the last
01:08:39 - 01:08:41: example you'll realize why this is not
01:08:41 - 01:08:43: going to work
01:08:41 - 01:08:45: it says 1 is an invalid keyword argument
01:08:43 - 01:08:47: for print so what this is going to do
01:08:45 - 01:08:48: when i unpack quarks
01:08:47 - 01:08:51: is it's going to take all my keyword
01:08:48 - 01:08:53: arguments and it's going to say 1 equals
01:08:51 - 01:08:55: 0 and it's going to say 2 equals 1 and
01:08:53 - 01:08:57: pass that to the print statement
01:08:55 - 01:08:58: now obviously 1 and 2 well those are not
01:08:57 - 01:09:00: valid arguments for the print statement
01:08:58 - 01:09:02: so we're going to get an error
01:09:00 - 01:09:03: anyways that is args and that is quarks
01:09:02 - 01:09:04: you're going to have to look into this
01:09:03 - 01:09:06: on your own and kind of learn about how
01:09:04 - 01:09:08: it works but that is the basics and i
01:09:06 - 01:09:09: just wanted to show that to you
01:09:08 - 01:09:11: so that you're aware that you can do
01:09:09 - 01:09:12: these cool fancy things in python
01:09:11 - 01:09:14: this next one is going to be very fast
01:09:12 - 01:09:16: but this is just defining scope and
01:09:14 - 01:09:17: global so when we look at a function
01:09:16 - 01:09:18: like this
01:09:17 - 01:09:21: there is a notion of a scope so we have
01:09:18 - 01:09:22: x equals tim we have defined func
01:09:21 - 01:09:23: and then we have name as a parameter and
01:09:22 - 01:09:24: what we're doing is we're saying okay
01:09:23 - 01:09:26: we're going to change
01:09:24 - 01:09:28: x to be equal to name so essentially if
01:09:26 - 01:09:29: i was naive and i didn't know any better
01:09:28 - 01:09:30: i would assume that what's going to
01:09:29 - 01:09:31: happen is while this variable up here
01:09:30 - 01:09:34: would change
01:09:31 - 01:09:35: when i pass this name to this function
01:09:34 - 01:09:36: any of you that program before probably
01:09:35 - 01:09:37: know that's not going to work but if you
01:09:36 - 01:09:38: have a look here
01:09:37 - 01:09:40: you can see that x does not change
01:09:38 - 01:09:42: before or after when i call func with
01:09:40 - 01:09:43: the string changed
01:09:42 - 01:09:46: the reason for that is that this x
01:09:43 - 01:09:47: variable is local it is within the scope
01:09:46 - 01:09:49: of this function
01:09:47 - 01:09:51: which means it cannot be used access
01:09:49 - 01:09:53: change from with from outside
01:09:51 - 01:09:55: the same thing here with this x this one
01:09:53 - 01:09:57: is actually global this is on you know
01:09:55 - 01:09:59: not not defined within any scope other
01:09:57 - 01:10:00: than this file which means well i can't
01:09:59 - 01:10:01: just directly change it from this
01:10:00 - 01:10:03: function
01:10:01 - 01:10:04: i could however access it from this
01:10:03 - 01:10:06: function i could print it here but i
01:10:04 - 01:10:07: can't actually change its value because
01:10:06 - 01:10:09: if i do that what's going to happen is
01:10:07 - 01:10:09: i'm going to create a new x inside of
01:10:09 - 01:10:11: here
01:10:09 - 01:10:12: which is equal to name and it will be
01:10:11 - 01:10:13: local to this function it will not
01:10:12 - 01:10:14: modify this
01:10:13 - 01:10:16: however there is one interesting thing
01:10:14 - 01:10:17: we can do in python which is the global
01:10:16 - 01:10:19: keyword
01:10:17 - 01:10:22: if i global x now you're going to notice
01:10:19 - 01:10:24: that the expected behavior will occur
01:10:22 - 01:10:25: now we get tim and we get change what
01:10:24 - 01:10:27: that is saying is okay i want to use
01:10:25 - 01:10:30: x as a global variable so i want to
01:10:27 - 01:10:31: reference x in the global scope never
01:10:30 - 01:10:32: use this this is
01:10:31 - 01:10:34: never good to use and if i ever see a
01:10:32 - 01:10:35: python program that has it i always get
01:10:34 - 01:10:37: upset
01:10:35 - 01:10:38: but this is something that you can use
01:10:37 - 01:10:39: and i feel obligated to show you because
01:10:38 - 01:10:41: there is some very
01:10:39 - 01:10:42: very rare situations where you may need
01:10:41 - 01:10:44: to use that all right so now i'm going
01:10:42 - 01:10:46: to spend about 10 seconds showing you
01:10:44 - 01:10:46: how to actually raise an exception in
01:10:46 - 01:10:48: python
01:10:46 - 01:10:50: there's a keyword called raise maybe in
01:10:48 - 01:10:51: java you've seen something like throw
01:10:50 - 01:10:52: and raise can raise an exception if you
01:10:51 - 01:10:53: wanted to do that so i could raise
01:10:52 - 01:10:55: exception
01:10:53 - 01:10:57: and then inside of here i could just say
01:10:55 - 01:10:58: bad you know whatever i want now if i
01:10:57 - 01:10:59: run the program as soon as we hit that
01:10:58 - 01:11:00: line
01:10:59 - 01:11:01: immediately i'm going to get an
01:11:00 - 01:11:02: exception and it says raised exception
01:11:01 - 01:11:04: bad
01:11:02 - 01:11:06: exception bad of course that is the
01:11:04 - 01:11:07: basics there is more arguments and
01:11:06 - 01:11:09: things you can do with this this is a
01:11:07 - 01:11:10: base class which means you can extend it
01:11:09 - 01:11:11: when you get to object oriented
01:11:10 - 01:11:12: programming
01:11:11 - 01:11:14: make your own exceptions and make all
01:11:12 - 01:11:15: that fancy stuff
01:11:14 - 01:11:17: for our cases that's all we really need
01:11:15 - 01:11:19: to know i could raise say like a file
01:11:17 - 01:11:21: exists error any other kind of error
01:11:19 - 01:11:22: that i want and then again add some
01:11:21 - 01:11:23: description for it by just putting a
01:11:22 - 01:11:25: string
01:11:23 - 01:11:26: inside of the brackets but that's enough
01:11:25 - 01:11:28: for that now let's show how we can
01:11:26 - 01:11:29: actually handle exceptions
01:11:28 - 01:11:31: all right so now that we know how to
01:11:29 - 01:11:33: raise exceptions it makes sense to learn
01:11:31 - 01:11:34: how to handle them so in python rather
01:11:33 - 01:11:37: than having like a try catch
01:11:34 - 01:11:37: we actually have a try except finally
01:11:37 - 01:11:39: block
01:11:37 - 01:11:40: so what i can do is do something like
01:11:39 - 01:11:42: try that means i'm going to try to
01:11:40 - 01:11:43: perform whatever code is inside of here
01:11:42 - 01:11:45: maybe i'm going to get an integer
01:11:43 - 01:11:45: division by zero error so i can do you
01:11:45 - 01:11:48: know
01:11:45 - 01:11:49: 7 over 0 that's going to raise an error
01:11:48 - 01:11:51: then i can create an except block i can
01:11:49 - 01:11:52: accept an exception as
01:11:51 - 01:11:54: e what this is going to do is mean
01:11:52 - 01:11:55: whatever the exception is will be stored
01:11:54 - 01:11:57: in the variable e and then so i could
01:11:55 - 01:11:58: print out that exception and we can
01:11:57 - 01:12:00: continue running the program
01:11:58 - 01:12:01: this is the basic try except block you
01:12:00 - 01:12:03: don't actually need to define something
01:12:01 - 01:12:04: here i can just say try accept like that
01:12:03 - 01:12:06: if i want
01:12:04 - 01:12:08: and also accept a specific exception so
01:12:06 - 01:12:10: i don't have to just put exception
01:12:08 - 01:12:11: this is general this means any exception
01:12:10 - 01:12:13: that occurs i will actually catch
01:12:11 - 01:12:15: you can only catch specific exceptions
01:12:13 - 01:12:17: if you want but again that's up to you
01:12:15 - 01:12:18: so in this case you see we get division
01:12:17 - 01:12:19: by zero it's just printing out but it
01:12:18 - 01:12:21: didn't actually raise or
01:12:19 - 01:12:23: you know show us that error so it did
01:12:21 - 01:12:26: raise it but we didn't actually see it
01:12:23 - 01:12:28: now if i go ahead and just do this what
01:12:26 - 01:12:30: we can do is we can say oh well that is
01:12:28 - 01:12:31: the actual problem and now our program
01:12:30 - 01:12:33: is going to crash and
01:12:31 - 01:12:34: not work but if we have this except
01:12:33 - 01:12:35: block like this of course we're good to
01:12:34 - 01:12:36: go
01:12:35 - 01:12:38: now there also is a notion of a finally
01:12:36 - 01:12:40: block the final block will run
01:12:38 - 01:12:42: no matter what usually you put clean up
01:12:40 - 01:12:43: type operations inside of here
01:12:42 - 01:12:45: maybe you're trying to write to a file
01:12:43 - 01:12:46: some exception occurs and then no matter
01:12:45 - 01:12:47: if this
01:12:46 - 01:12:48: was successful or not you want to close
01:12:47 - 01:12:49: the file after you would put that inside
01:12:48 - 01:12:53: of finally
01:12:49 - 01:12:55: so i could say print finally like that
01:12:53 - 01:12:56: have a look here and you can see we get
01:12:55 - 01:12:57: finally i'm not going to go through this
01:12:56 - 01:12:59: too much i assume if you're going to be
01:12:57 - 01:13:01: using this you understand how try
01:12:59 - 01:13:02: accept and finally work but that is the
01:13:01 - 01:13:05: implementation in python
01:13:02 - 01:13:06: and that is the basics for raising and
01:13:05 - 01:13:07: catching an error
01:13:06 - 01:13:09: and now we're going to discuss the
01:13:07 - 01:13:10: lambdas so lambdas are actually a really
01:13:09 - 01:13:12: cool aspect of python i'm pretty sure
01:13:10 - 01:13:13: they have them in many other programming
01:13:12 - 01:13:14: languages as well but it looks something
01:13:13 - 01:13:17: like
01:13:14 - 01:13:19: this essentially a lambda is a one-line
01:13:17 - 01:13:21: anonymous function what that means is
01:13:19 - 01:13:23: not really a named function
01:13:21 - 01:13:24: you don't define a lambda using the def
01:13:23 - 01:13:24: keyword what you can do is something
01:13:24 - 01:13:28: like x
01:13:24 - 01:13:30: equals lambda x and then x plus five
01:13:28 - 01:13:32: what this means is this lambda is going
01:13:30 - 01:13:34: to take one argument which is x
01:13:32 - 01:13:36: and it's going to return x plus 5 not
01:13:34 - 01:13:38: multiplied by x do i mean to do that
01:13:36 - 01:13:40: that means if i call x like this and i
01:13:38 - 01:13:42: go i don't know x2 and we print
01:13:40 - 01:13:44: this let's just go ahead and have a look
01:13:42 - 01:13:47: at this here
01:13:44 - 01:13:49: oops again did not mean to do that we
01:13:47 - 01:13:51: see that we get the value 7. now i will
01:13:49 - 01:13:52: note that this is not the advised way to
01:13:51 - 01:13:54: use a lambda we're going to see how to
01:13:52 - 01:13:55: use it in just a second in the next
01:13:54 - 01:13:56: section
01:13:55 - 01:13:58: but this is the basics of how it works
01:13:56 - 01:13:59: it's just a one-line anonymous function
01:13:58 - 01:14:01: so i can do something like x
01:13:59 - 01:14:03: y as well and then i can do something
01:14:01 - 01:14:05: like x plus y
01:14:03 - 01:14:06: not capital y and if i go ahead and call
01:14:05 - 01:14:09: x with i don't know 2
01:14:06 - 01:14:11: 3 or 232 sure that's fine let's have a
01:14:09 - 01:14:13: look here we get the value 34.
01:14:11 - 01:14:14: so hopefully that makes sense on how the
01:14:13 - 01:14:16: lambda works it looks intimidating but
01:14:14 - 01:14:18: it's really not that complicated and
01:14:16 - 01:14:20: in the next one you'll see why these are
01:14:18 - 01:14:20: useful and now i'm going to talk to you
01:14:20 - 01:14:22: about map
01:14:20 - 01:14:24: and filter which are two useful
01:14:22 - 01:14:25: functions in python which make use of
01:14:24 - 01:14:26: the lambda functions
01:14:25 - 01:14:28: now you don't necessarily need to use
01:14:26 - 01:14:30: lambda function but a lot of times it
01:14:28 - 01:14:30: comes in handy so let me show you what i
01:14:30 - 01:14:33: mean
01:14:30 - 01:14:35: let's make a list let's add oops i
01:14:33 - 01:14:37: wanted to do a few more commas than that
01:14:35 - 01:14:38: let's add a bunch of elements inside of
01:14:37 - 01:14:40: here to make it kind of nice and long so
01:14:38 - 01:14:41: we get some interesting output
01:14:40 - 01:14:43: and now what i'm going to do is i'm
01:14:41 - 01:14:45: simply going to show you how we use map
01:14:43 - 01:14:47: so what map will do is we'll take all of
01:14:45 - 01:14:49: the elements of a list
01:14:47 - 01:14:50: and use a function to map them into a
01:14:49 - 01:14:52: new list so if i say something like mp
01:14:50 - 01:14:53: standing for you know map
01:14:52 - 01:14:56: i can say map which is the actual
01:14:53 - 01:14:57: function now what i do is i put a
01:14:56 - 01:14:59: function inside of here that i want to
01:14:57 - 01:15:00: use for the map
01:14:59 - 01:15:02: so this will make sense in a second but
01:15:00 - 01:15:04: i'm going to say lambda x
01:15:02 - 01:15:06: x plus 2. so this is essentially saying
01:15:04 - 01:15:08: add 2 to every single one of these
01:15:06 - 01:15:10: elements or add 2 to x in this case
01:15:08 - 01:15:12: and then what i do is simply pass x now
01:15:10 - 01:15:13: i know x is kind of confusing so maybe
01:15:12 - 01:15:15: we'll just change this to i so that's
01:15:13 - 01:15:16: easier to differentiate
01:15:15 - 01:15:19: but what this is going to do is say okay
01:15:16 - 01:15:21: we're going to map all of the elements
01:15:19 - 01:15:23: inside of x so in this list x to this
01:15:21 - 01:15:25: lambda function which means take this
01:15:23 - 01:15:26: lambda function and apply it on every
01:15:25 - 01:15:28: single element of x and then put that
01:15:26 - 01:15:29: into a new list
01:15:28 - 01:15:31: now what i'm going to do is i'm going to
01:15:29 - 01:15:33: print the list representation of
01:15:31 - 01:15:34: mp map actually returns to us a map
01:15:33 - 01:15:35: object
01:15:34 - 01:15:36: we can use that if we're going to
01:15:35 - 01:15:38: iterate over it but it's usually more
01:15:36 - 01:15:38: useful just to convert it right into a
01:15:38 - 01:15:40: list
01:15:38 - 01:15:42: so let's have a look at what this does
01:15:40 - 01:15:42: and there we go now we get three four
01:15:42 - 01:15:43: six
01:15:42 - 01:15:46: and you can see all these elements have
01:15:43 - 01:15:47: been added by two now we can do a more
01:15:46 - 01:15:48: complicated one maybe we can multiply by
01:15:47 - 01:15:50: two
01:15:48 - 01:15:52: you'll see more of a difference and
01:15:50 - 01:15:52: there we go now the next function i want
01:15:52 - 01:15:54: to show you is
01:15:52 - 01:15:56: filter so hopefully you get the idea of
01:15:54 - 01:15:57: how map works but filter
01:15:56 - 01:15:59: i don't want to say it the opposite but
01:15:57 - 01:16:00: it does something a little bit different
01:15:59 - 01:16:01: so this function here which is lambda
01:16:00 - 01:16:03: what it's going to do is instead of
01:16:01 - 01:16:05: actually returning
01:16:03 - 01:16:06: some value it's going to return true or
01:16:05 - 01:16:08: false and it's going to tell us
01:16:06 - 01:16:11: whether or not we should include the
01:16:08 - 01:16:12: item in our final filtered list or
01:16:11 - 01:16:14: filtered object
01:16:12 - 01:16:15: so essentially this lambda function or
01:16:14 - 01:16:17: whatever function we put inside of here
01:16:15 - 01:16:19: has to return true or false based on the
01:16:17 - 01:16:20: value of an item so what i could do is
01:16:19 - 01:16:23: say something like
01:16:20 - 01:16:24: i is i mod 2 equals equals 0. so this
01:16:23 - 01:16:25: means you know only return it if it's
01:16:24 - 01:16:27: even
01:16:25 - 01:16:28: so this is the function take some value
01:16:27 - 01:16:30: i tells us
01:16:28 - 01:16:32: if it's equal to or sorry divisible by 0
01:16:30 - 01:16:33: and if it is we'll include it so let's
01:16:32 - 01:16:34: have a look now
01:16:33 - 01:16:36: and you can see that we only get all of
01:16:34 - 01:16:38: the even elements in our list
01:16:36 - 01:16:39: now of course what we can do is also
01:16:38 - 01:16:41: define a more complicated function so we
01:16:39 - 01:16:43: can say define func
01:16:41 - 01:16:44: take some value let's go with i and we
01:16:43 - 01:16:45: can do the same thing here we could say
01:16:44 - 01:16:48: return i
01:16:45 - 01:16:48: mod 2 equals equals 0 but we could also
01:16:48 - 01:16:52: say you know i
01:16:48 - 01:16:54: equals i multiplied by 3 so
01:16:52 - 01:16:55: we can do that and then we can say i mod
01:16:54 - 01:16:57: 2 equals equals 0.
01:16:55 - 01:16:58: then instead of using a lambda here we
01:16:57 - 01:17:00: could simply just write func
01:16:58 - 01:17:01: that's totally fine so we just put the
01:17:00 - 01:17:03: name of the function that we want to use
01:17:01 - 01:17:04: and then we run this and it works fine
01:17:03 - 01:17:05: but this is why
01:17:04 - 01:17:06: lambda is useful because a lot of times
01:17:05 - 01:17:07: you don't want to define your own
01:17:06 - 01:17:09: function up here
01:17:07 - 01:17:10: you just want to define it right inside
01:17:09 - 01:17:11: of the map statement or the filter
01:17:10 - 01:17:14: statement so that's
01:17:11 - 01:17:15: kind of where you would use this there's
01:17:14 - 01:17:17: another few use cases for it but this is
01:17:15 - 01:17:19: kind of the most common and where you'll
01:17:17 - 01:17:22: often see it so anyways that
01:17:19 - 01:17:24: is map and filter and for our last
01:17:22 - 01:17:25: and final topic i'm going to be covering
01:17:24 - 01:17:28: something called f strings
01:17:25 - 01:17:29: now f strings are new in python 3.6 if
01:17:28 - 01:17:31: you have any version lower than that you
01:17:29 - 01:17:32: are not going to be able to use
01:17:31 - 01:17:34: f strings but they're a really cool way
01:17:32 - 01:17:36: to actually just manipulate and create
01:17:34 - 01:17:37: strings so what i can do is do something
01:17:36 - 01:17:39: like x equals i can do an
01:17:37 - 01:17:41: uh lowercase f or a capital f it doesn't
01:17:39 - 01:17:43: matter and then a string
01:17:41 - 01:17:44: notice that this will highlight or maybe
01:17:43 - 01:17:45: it'll be a towel size depending on what
01:17:44 - 01:17:47: editor you're using
01:17:45 - 01:17:49: and well what you can do is type a
01:17:47 - 01:17:50: string as you normally would except now
01:17:49 - 01:17:52: if you want to embed an expression what
01:17:50 - 01:17:54: you can do is do that inside of curly
01:17:52 - 01:17:55: brackets so i can do hello and then i
01:17:54 - 01:17:58: could say like you know
01:17:55 - 01:17:59: six plus eight and this will actually be
01:17:58 - 01:18:02: evaluated and now when i print this out
01:17:59 - 01:18:03: it will give me the answer 14. so this
01:18:02 - 01:18:05: is great because if you have some
01:18:03 - 01:18:07: variables say like i have you know
01:18:05 - 01:18:08: i don't know tim equals 89 or something
01:18:07 - 01:18:10: and i want to embed that in the string
01:18:08 - 01:18:12: without having to concatenate it and
01:18:10 - 01:18:13: convert it into a string with str
01:18:12 - 01:18:15: i can simply just use the f string and
01:18:13 - 01:18:17: just embed it with all the formatting
01:18:15 - 01:18:19: uh by putting it inside of these curly
01:18:17 - 01:18:20: braid braces so that is kind of how
01:18:19 - 01:18:22: that works you can go ahead and mess
01:18:20 - 01:18:23: around with this if you want to really
01:18:22 - 01:18:25: see how it works but essentially you
01:18:23 - 01:18:26: just put an expression inside of these
01:18:25 - 01:18:27: curly braces
01:18:26 - 01:18:29: it will be evaluated and then it will
01:18:27 - 01:18:31: turn into a string really great easy way
01:18:29 - 01:18:33: to work with strings of course you can
01:18:31 - 01:18:34: print an f string as well i could print
01:18:33 - 01:18:36: hello
01:18:34 - 01:18:38: and then we can do that and in fact
01:18:36 - 01:18:40: let's run this and just see what we get
01:18:38 - 01:18:42: and there we go we see we get hello 89
01:18:40 - 01:18:44: so that is f strings
01:18:42 - 01:18:45: so with that being said i'm going to
01:18:44 - 01:18:48: conclude the video here i
01:18:45 - 01:18:49: am officially out of breath i went very
01:18:48 - 01:18:51: fast through this tutorial
01:18:49 - 01:18:53: with the purpose of making it as quick
01:18:51 - 01:18:55: as possible and not wasting any of your
01:18:53 - 01:18:56: time if you guys appreciate this effort
01:18:55 - 01:18:58: please do leave a like
01:18:56 - 01:18:59: subscribe to the channel and of course
01:18:58 - 01:19:01: let me know what you want to see next i
01:18:59 - 01:19:03: will quickly mention that i did miss a
01:19:01 - 01:19:05: few things in this video
01:19:03 - 01:19:07: specifically object oriented programming
01:19:05 - 01:19:08: and advanced language features
01:19:07 - 01:19:09: if you would like to know about those
01:19:08 - 01:19:11: two things i have a ton of resources
01:19:09 - 01:19:12: related to them i will leave them in the
01:19:11 - 01:19:14: description
01:19:12 - 01:19:16: the first is a about an hour long video
01:19:14 - 01:19:18: on object oriented programming in python
01:19:16 - 01:19:19: that covers kind of all the fundamentals
01:19:18 - 01:19:21: and everything you need to know
01:19:19 - 01:19:23: the next one is a whole series on expert
01:19:21 - 01:19:24: level features in python i believe
01:19:23 - 01:19:26: that's about six videos and covers
01:19:24 - 01:19:28: things like meta classes context
01:19:26 - 01:19:30: managers generators all of that
01:19:28 - 01:19:32: anyways as i said i hope you enjoy leave
01:19:30 - 01:19:36: a like subscribe i will see you in the
01:19:32 - 01:19:40: next one
01:19:36 - 01:19:42: [Music]
01:19:40 - 01:19:42: you
