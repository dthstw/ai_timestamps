00:00:01 - 00:00:05: hi everyone and welcome to a new episode
00:00:04 - 00:00:07: of coding adventures
00:00:05 - 00:00:09: today we're going to be exploring the
00:00:07 - 00:00:10: game of chats
00:00:09 - 00:00:13: let's begin simply by creating the
00:00:10 - 00:00:15: chessboard so we'll need two loops for
00:00:13 - 00:00:16: the x and y axes or files and ranks if
00:00:15 - 00:00:18: you prefer
00:00:16 - 00:00:20: and to tell if a square should be
00:00:18 - 00:00:21: colored light or dark we can just check
00:00:20 - 00:00:25: whether or not the file
00:00:21 - 00:00:25: plus the rank is divisible by two
00:00:26 - 00:00:30: let's try running this code and here we
00:00:28 - 00:00:32: have our very humble beginnings
00:00:30 - 00:00:34: i expect i'll be staring at these 64
00:00:32 - 00:00:36: squares a lot in the coming days or
00:00:34 - 00:00:37: weeks depending on how challenging this
00:00:36 - 00:00:38: turns out to be
00:00:37 - 00:00:40: so i'll tweak these colors to something
00:00:38 - 00:00:43: a little easier on the eyes
00:00:40 - 00:00:45: [Music]
00:00:43 - 00:00:47: next we'll need some pieces and i found
00:00:45 - 00:00:48: this nice design online which came along
00:00:47 - 00:00:51: with some interesting
00:00:48 - 00:00:52: additional ideas for a giraffe a zebra
00:00:51 - 00:00:55: whatever this is
00:00:52 - 00:00:56: and several more i think chess is
00:00:55 - 00:01:00: confusing enough as it is though
00:00:56 - 00:01:01: so i'll stick to these for now
00:01:00 - 00:01:04: we then need to represent these pieces
00:01:01 - 00:01:05: in code so i'll assign each type of
00:01:04 - 00:01:08: piece a number
00:01:05 - 00:01:09: along with a number for white and black
00:01:08 - 00:01:10: these values could be pretty much
00:01:09 - 00:01:11: anything
00:01:10 - 00:01:13: but i chose these particular one so that
00:01:11 - 00:01:15: if we look at a piece in binary
00:01:13 - 00:01:18: the three bits on the right will tell us
00:01:15 - 00:01:19: what type of piece it is
00:01:18 - 00:01:21: and then the two bits on the left tell
00:01:19 - 00:01:24: us if it has a color associated with it
00:01:21 - 00:01:27: which can be white or black so
00:01:24 - 00:01:29: let's now create an array of 64 numbers
00:01:27 - 00:01:31: which will be the computer's internal
00:01:29 - 00:01:33: representation of the chessboard
00:01:31 - 00:01:35: these are all zero by default but we
00:01:33 - 00:01:38: could place for example on square zero
00:01:35 - 00:01:39: a white bishop and on square 63 a black
00:01:38 - 00:01:41: queen
00:01:39 - 00:01:43: and whatever else we want behind the
00:01:41 - 00:01:44: scenes i also added some code for
00:01:43 - 00:01:46: actually displaying the pieces
00:01:44 - 00:01:48: i'm not sure if they're obscuring quite
00:01:46 - 00:01:52: enough of the board at the moment though
00:01:48 - 00:01:52: so let me fix that perfect
00:01:53 - 00:01:57: now instead of setting up the board
00:01:55 - 00:01:58: piece by piece in that array
00:01:57 - 00:02:00: i'd like to support the standard
00:01:58 - 00:02:02: notation called fen
00:02:00 - 00:02:03: here's an example of a fen string which
00:02:02 - 00:02:04: might look terribly cryptic at first
00:02:03 - 00:02:06: glance but
00:02:04 - 00:02:08: it's actually really simple we start at
00:02:06 - 00:02:10: the top left square and here we have
00:02:08 - 00:02:12: seven empty spaces
00:02:10 - 00:02:14: followed by a lowercase k meaning
00:02:12 - 00:02:15: there's a black king hiding in this
00:02:14 - 00:02:17: corner
00:02:15 - 00:02:18: we then go to the next rank and skip
00:02:17 - 00:02:19: three spaces and here we have an
00:02:18 - 00:02:22: uppercase
00:02:19 - 00:02:23: n meaning a white knight you're probably
00:02:22 - 00:02:24: getting the idea already
00:02:23 - 00:02:27: so i'll spare you the tedium of going
00:02:24 - 00:02:27: through the rest
00:02:29 - 00:02:32: i've written up this little function to
00:02:31 - 00:02:34: translate those fence strings into the
00:02:32 - 00:02:35: format we're using
00:02:34 - 00:02:37: and up at the top here i'll write out
00:02:35 - 00:02:40: the fan for the starting position
00:02:37 - 00:02:40: so we can load that in
00:02:41 - 00:02:46: and here it is i've also implemented
00:02:44 - 00:02:47: some simple drag and drop behavior for
00:02:46 - 00:02:48: the pieces
00:02:47 - 00:02:51: although it's not quite behaving how i
00:02:48 - 00:02:51: hoped
00:02:53 - 00:02:57: i'll go ahead and fix that quickly so
00:02:55 - 00:03:00: now it's making the pieces disappear for
00:02:57 - 00:03:00: some reason
00:03:01 - 00:03:04: i'm rapidly losing faith in my ability
00:03:03 - 00:03:06: to code anything but
00:03:04 - 00:03:07: i have at last got it working and i
00:03:06 - 00:03:08: think it's looking nice
00:03:07 - 00:03:10: although of course nothing's really
00:03:08 - 00:03:11: stopping me from sneaking in a move like
00:03:10 - 00:03:13: this
00:03:11 - 00:03:15: when my opponent's not paying attention
00:03:13 - 00:03:15: so the first real challenge of this
00:03:15 - 00:03:17: project
00:03:15 - 00:03:21: is going to be calculating what the
00:03:17 - 00:03:22: legal moves are in any given position
00:03:21 - 00:03:24: [Music]
00:03:22 - 00:03:26: so these are the indices of our squares
00:03:24 - 00:03:28: and from any square we can move
00:03:26 - 00:03:29: orthogonally like a rook by adding these
00:03:28 - 00:03:31: offsets
00:03:29 - 00:03:34: and diagonally like a bishop with these
00:03:31 - 00:03:36: offsets
00:03:34 - 00:03:37: i'll write out those values and then i'm
00:03:36 - 00:03:39: going to make another little array
00:03:37 - 00:03:40: and when the program starts up it's
00:03:39 - 00:03:42: going to quickly calculate the number of
00:03:40 - 00:03:44: squares to the edge of the board
00:03:42 - 00:03:46: starting from each different square and
00:03:44 - 00:03:48: going in every
00:03:46 - 00:03:51: direction just so we can easily look up
00:03:48 - 00:03:51: that information when we need it
00:03:51 - 00:03:55: let's then define a little structure for
00:03:53 - 00:03:57: holding a move now we'll just record the
00:03:55 - 00:04:00: starting square and the target square
00:03:57 - 00:04:02: of the piece we want to move we can then
00:04:00 - 00:04:03: make a list of these moves
00:04:02 - 00:04:05: and a function for actually generating
00:04:03 - 00:04:07: them
00:04:05 - 00:04:09: what we can do in here is just loop over
00:04:07 - 00:04:11: all 64 squares
00:04:09 - 00:04:12: and see what piece is on each square and
00:04:11 - 00:04:14: we're only interested in the piece if
00:04:12 - 00:04:16: it's the right color for whoever's
00:04:14 - 00:04:18: turning it is to move
00:04:16 - 00:04:19: let's focus for now on the long range
00:04:18 - 00:04:23: sliding pieces
00:04:19 - 00:04:25: that's the bishop the rook and the queen
00:04:23 - 00:04:26: so in the sliding piece function we can
00:04:25 - 00:04:28: loop over the eight
00:04:26 - 00:04:29: different directions and for each
00:04:28 - 00:04:31: direction we'll also have a loop for the
00:04:29 - 00:04:33: number of squares that exist
00:04:31 - 00:04:35: in that direction up to the edge of the
00:04:33 - 00:04:35: board
00:04:36 - 00:04:39: now of course our movement might be
00:04:37 - 00:04:41: blocked by one of our own pieces
00:04:39 - 00:04:44: so let's skip to the next direction if
00:04:41 - 00:04:46: there's a friendly piece in the way
00:04:44 - 00:04:49: then we can create the move going from
00:04:46 - 00:04:51: the start square to the target square
00:04:49 - 00:04:53: and add it to the list of possible moves
00:04:51 - 00:04:54: finally if there's an enemy piece on the
00:04:53 - 00:04:56: target square
00:04:54 - 00:04:58: we'll be capturing it so then we can't
00:04:56 - 00:04:59: go any further than that
00:04:58 - 00:05:01: and we'll need to skip to the next
00:04:59 - 00:05:02: direction there as well
00:05:01 - 00:05:04: this should work for the queen which
00:05:02 - 00:05:06: moves in all eight directions
00:05:04 - 00:05:08: but if it's a bishop we only want to
00:05:06 - 00:05:09: look at the last four directions
00:05:08 - 00:05:12: or if it's a rook then just the first
00:05:09 - 00:05:14: fall so i've added some logic here for
00:05:12 - 00:05:16: handling that
00:05:14 - 00:05:17: if we now try this out on the board the
00:05:16 - 00:05:21: sliding pieces should all be
00:05:17 - 00:05:21: obediently obeying the rules
00:05:22 - 00:05:25: i then spent some time carefully
00:05:24 - 00:05:26: implementing the rules for the remaining
00:05:25 - 00:05:28: pieces
00:05:26 - 00:05:33: but i'll spare you a detailed account of
00:05:28 - 00:05:33: [Music]
00:05:36 - 00:05:39: that
00:05:46 - 00:05:50: so at long last the knights are free to
00:05:48 - 00:05:52: leap about we can push the pawns
00:05:50 - 00:05:54: and i've even got the hottest new moves
00:05:52 - 00:05:55: from the 15th century like double pawn
00:05:54 - 00:05:56: pushes
00:05:55 - 00:05:59: and on
00:05:56 - 00:05:59: [Music]
00:06:00 - 00:06:05: pawns can also become queens or knights
00:06:03 - 00:06:08: bishops and rooks if they prefer
00:06:05 - 00:06:08: and we can castle the kings
00:06:09 - 00:06:12: the only thing not yet implemented and
00:06:11 - 00:06:15: it's kind of important
00:06:12 - 00:06:17: is the concept of check right now if the
00:06:15 - 00:06:18: king is under attack you can just ignore
00:06:17 - 00:06:19: it so the moves at the moment are what's
00:06:18 - 00:06:22: called
00:06:19 - 00:06:23: pseudo-legal the easiest way i can think
00:06:22 - 00:06:25: of for fixing this
00:06:23 - 00:06:26: is a little gross but it's to take each
00:06:25 - 00:06:28: pseudo-legal move
00:06:26 - 00:06:30: play it on the board and then look at
00:06:28 - 00:06:32: all the opponent's responses
00:06:30 - 00:06:34: if any of those responses is a capture
00:06:32 - 00:06:35: of our king we know that our last move
00:06:34 - 00:06:37: must have been illegal
00:06:35 - 00:06:38: and in that way we can filter through
00:06:37 - 00:06:42: just the legal moves
00:06:38 - 00:06:44: [Music]
00:06:42 - 00:06:46: let's put this to the test quickly so
00:06:44 - 00:06:47: here for example if i try move one of
00:06:46 - 00:06:49: black's pawns
00:06:47 - 00:06:51: we can see it has no legal moves if i
00:06:49 - 00:06:52: select the knight though we can either
00:06:51 - 00:06:56: block the check
00:06:52 - 00:06:57: or capture the queen so now that we have
00:06:56 - 00:06:58: legal moves let's create our first
00:06:57 - 00:07:01: adversary
00:06:58 - 00:07:01: one who plays moves completely at random
00:07:01 - 00:07:03: round
00:07:01 - 00:07:07: one fight
00:07:03 - 00:07:07: [Music]
00:07:09 - 00:07:13: okay it turns out that playing randomly
00:07:11 - 00:07:14: is not really a viable strategy
00:07:13 - 00:07:18: just for fun though let's put the
00:07:14 - 00:07:18: computer against itself
00:07:18 - 00:07:22: truly a beautiful game now i'd like to
00:07:21 - 00:07:24: get the computer playing a lot better
00:07:22 - 00:07:26: than random of course
00:07:24 - 00:07:27: so experienced human players rely
00:07:26 - 00:07:28: heavily on pattern recognition and
00:07:27 - 00:07:30: intuition
00:07:28 - 00:07:32: and even when calculating concrete
00:07:30 - 00:07:33: sequences of moves they only really
00:07:32 - 00:07:34: consider a tiny fraction of the
00:07:33 - 00:07:36: possibilities
00:07:34 - 00:07:37: with most being subconsciously rejected
00:07:36 - 00:07:40: as irrelevant
00:07:37 - 00:07:41: programming a computer in this way is
00:07:40 - 00:07:42: not easy
00:07:41 - 00:07:44: instead we want to play to the
00:07:42 - 00:07:46: computer's strengths by crunching
00:07:44 - 00:07:48: millions of possible outcomes
00:07:46 - 00:07:49: to do that though move generation needs
00:07:48 - 00:07:52: to be pretty speedy
00:07:49 - 00:07:55: and mine is the exact opposite of that
00:07:52 - 00:07:56: so much time rolled by as i mashed away
00:07:55 - 00:07:58: at the keyboard trying out different
00:07:56 - 00:07:59: ideas and of course
00:07:58 - 00:08:01: fixing the seemingly endless supply of
00:07:59 - 00:08:02: bugs i created along the way
00:08:01 - 00:08:04: as i tried to speed up the move
00:08:02 - 00:08:05: generation so that my computer would be
00:08:04 - 00:08:08: able to look further into the future
00:08:05 - 00:08:10: [Music]
00:08:08 - 00:08:12: one of the things i did was take this
00:08:10 - 00:08:15: old code for filtering out illegal moves
00:08:12 - 00:08:17: and throw it away
00:08:15 - 00:08:19: instead i'm now keeping track of all the
00:08:17 - 00:08:20: squares that the opponent attacks
00:08:19 - 00:08:22: so we can easily detect if the king is
00:08:20 - 00:08:24: in check in which case it either needs
00:08:22 - 00:08:26: to move to a safe square
00:08:24 - 00:08:27: or some other piece needs to move to one
00:08:26 - 00:08:30: of these orange squares
00:08:27 - 00:08:31: to resolve the check of course this
00:08:30 - 00:08:33: knight for example
00:08:31 - 00:08:35: could block the check except that would
00:08:33 - 00:08:36: reveal another attack on the king from
00:08:35 - 00:08:38: this bishop
00:08:36 - 00:08:41: so i also calculate these lines for
00:08:38 - 00:08:43: limiting the movement of pinned pieces
00:08:41 - 00:08:45: along with some other optimizations like
00:08:43 - 00:08:46: keeping track of where all the pieces
00:08:45 - 00:08:48: are instead of having to loop over the
00:08:46 - 00:08:49: entire board to find them
00:08:48 - 00:08:51: i was able to speed things up a decent
00:08:49 - 00:08:53: amount
00:08:51 - 00:08:54: now i've been moving pieces around for a
00:08:53 - 00:08:56: while and it seems like everything's
00:08:54 - 00:08:58: working correctly
00:08:56 - 00:09:02: but it's possible i've missed something
00:08:58 - 00:09:02: so i'd like to set up a little test
00:09:02 - 00:09:06: let's write a function that gets all the
00:09:04 - 00:09:07: legal moves and one by one makes them on
00:09:06 - 00:09:10: the board
00:09:07 - 00:09:11: it then recursively calls itself so that
00:09:10 - 00:09:13: for each move it makes each of the
00:09:11 - 00:09:15: opponent's responses
00:09:13 - 00:09:17: and so on to infinity or more
00:09:15 - 00:09:17: realistically until my computer runs out
00:09:17 - 00:09:20: of memory
00:09:17 - 00:09:22: and crashes to circumvent that i'll add
00:09:20 - 00:09:23: a depth value that decreases with each
00:09:22 - 00:09:25: call
00:09:23 - 00:09:26: and when it reaches zero we'll stop
00:09:25 - 00:09:28: going any deeper
00:09:26 - 00:09:30: what this function is going to do is
00:09:28 - 00:09:31: simply count the number of positions
00:09:30 - 00:09:33: that are reached after a certain number
00:09:31 - 00:09:35: of moves
00:09:33 - 00:09:37: for example here's what it looks like
00:09:35 - 00:09:38: with a depth of two ply
00:09:37 - 00:09:41: which just means one move for white and
00:09:38 - 00:09:41: one move for black
00:09:42 - 00:09:47: the result if i speed this up quickly is
00:09:44 - 00:09:48: 400 positions
00:09:47 - 00:09:50: let's run this for a couple different
00:09:48 - 00:09:52: depths and we can see the number of
00:09:50 - 00:09:54: positions grows very rapidly
00:09:52 - 00:09:56: with almost 120 million possible
00:09:54 - 00:09:57: positions after just three moves for
00:09:56 - 00:09:59: each side
00:09:57 - 00:10:01: now what we can do is compare these
00:09:59 - 00:10:03: numbers to the consensus that's been
00:10:01 - 00:10:05: reached by other chess programmers
00:10:03 - 00:10:07: and it seems to match but obviously
00:10:05 - 00:10:09: there's a lot of scenarios that can't
00:10:07 - 00:10:10: arise so early on in the game
00:10:09 - 00:10:12: so let's try it out on this test
00:10:10 - 00:10:15: position which i came across on the
00:10:12 - 00:10:19: chest programming wiki
00:10:15 - 00:10:19: okay fingers crossed
00:10:20 - 00:10:24: so something in my code is wrong what a
00:10:23 - 00:10:26: surprise
00:10:24 - 00:10:28: to try figure it out i'm going to enlist
00:10:26 - 00:10:29: the help of one of the best chess
00:10:28 - 00:10:32: engines out there
00:10:29 - 00:10:33: stockfish i'll enter the test position
00:10:32 - 00:10:35: here and then
00:10:33 - 00:10:36: i'll ask it to run the same performance
00:10:35 - 00:10:37: test
00:10:36 - 00:10:40: the fish of course gets the correct
00:10:37 - 00:10:42: result but what's super helpful is it
00:10:40 - 00:10:42: gives this breakdown of the number of
00:10:42 - 00:10:45: positions
00:10:42 - 00:10:46: after each move which i can compare with
00:10:45 - 00:10:48: my output
00:10:46 - 00:10:50: to quickly trace exactly which moves my
00:10:48 - 00:10:52: program is getting wrong
00:10:50 - 00:10:53: the mistake i made involved castling
00:10:52 - 00:10:55: which surprised me because
00:10:53 - 00:10:57: i'd so carefully followed all the little
00:10:55 - 00:10:59: rules like if a rook moves then you lose
00:10:57 - 00:11:01: the right to castle on that side
00:10:59 - 00:11:03: even if it returns to its original
00:11:01 - 00:11:05: square but in this position if black
00:11:03 - 00:11:07: captures the rook i didn't think to
00:11:05 - 00:11:09: count that as the rook having moved
00:11:07 - 00:11:14: and so my program came up with this
00:11:09 - 00:11:15: creative response
00:11:14 - 00:11:17: [Music]
00:11:15 - 00:11:19: another position that caught me out was
00:11:17 - 00:11:20: this one here the pawn is pinned to the
00:11:19 - 00:11:23: king by the rook
00:11:20 - 00:11:24: and so it's unable to move but if i make
00:11:23 - 00:11:27: some other move and
00:11:24 - 00:11:28: black then pushes this pawn to up that
00:11:27 - 00:11:31: breaks the pin
00:11:28 - 00:11:32: another pawn is free to move again let
00:11:31 - 00:11:34: me undo that move though
00:11:32 - 00:11:36: because there's also that sneaky arm
00:11:34 - 00:11:37: passang rule where a pawn that moves two
00:11:36 - 00:11:38: squares
00:11:37 - 00:11:40: can be captured as if it had only moved
00:11:38 - 00:11:42: one square
00:11:40 - 00:11:44: so that works but in this case that
00:11:42 - 00:11:47: reveals the attack of the rook again
00:11:44 - 00:11:48: and so the move is actually illegal with
00:11:47 - 00:11:51: those fixed it's now passing all the
00:11:48 - 00:11:52: tests i've thrown at it so far
00:11:51 - 00:11:54: it's still slower than i'd hoped to be
00:11:52 - 00:11:56: honest but i think it's time to start
00:11:54 - 00:11:59: working on a more challenging
00:11:56 - 00:12:00: opponent there've actually been some
00:11:59 - 00:12:02: breakthroughs fairly recently in the
00:12:00 - 00:12:04: exciting world of chess programming
00:12:02 - 00:12:06: involving techniques like neural
00:12:04 - 00:12:08: networks and monty college research
00:12:06 - 00:12:10: which i'm very curious to learn more
00:12:08 - 00:12:12: about but for now i'm going to go with a
00:12:10 - 00:12:14: more old school approach
00:12:12 - 00:12:16: let's begin by making an evaluation
00:12:14 - 00:12:18: function to try gauge how good a
00:12:16 - 00:12:20: position is
00:12:18 - 00:12:21: to do this we can decide how much each
00:12:20 - 00:12:23: type of piece is generally worth
00:12:21 - 00:12:25: so knights and bishops are probably
00:12:23 - 00:12:27: worth about three pawns each
00:12:25 - 00:12:28: a rook is worth a little more and a
00:12:27 - 00:12:31: queen is somewhere in the vicinity of
00:12:28 - 00:12:31: two rooks
00:12:32 - 00:12:35: we can then add up the value of each
00:12:33 - 00:12:37: side's pieces like so
00:12:35 - 00:12:39: and what we'll then do is subtract the
00:12:37 - 00:12:40: one from the other to end up with a
00:12:39 - 00:12:42: value that's zero
00:12:40 - 00:12:44: if the position is equal positive if the
00:12:42 - 00:12:45: side whose turn it is to move is doing
00:12:44 - 00:12:47: better
00:12:45 - 00:12:48: and negative if the other side is doing
00:12:47 - 00:12:49: better
00:12:48 - 00:12:50: obviously there's much more to
00:12:49 - 00:12:52: evaluating a position than simply
00:12:50 - 00:12:55: counting the pieces but this seems like
00:12:52 - 00:12:56: a decent place to start
00:12:55 - 00:12:58: we can now write a little search
00:12:56 - 00:12:59: function which should look familiar
00:12:58 - 00:13:01: because it's the same idea
00:12:59 - 00:13:02: as that move generation test we did a
00:13:01 - 00:13:04: few minutes ago
00:13:02 - 00:13:06: but instead of counting the number of
00:13:04 - 00:13:08: positions after however many moves
00:13:06 - 00:13:09: it's going to evaluate those end
00:13:08 - 00:13:11: positions
00:13:09 - 00:13:13: we should also account for the fact that
00:13:11 - 00:13:14: if there are no legal moves available
00:13:13 - 00:13:16: then it's either checkmate in which case
00:13:14 - 00:13:18: we can return negative infinity because
00:13:16 - 00:13:20: what could be worse than losing a game
00:13:18 - 00:13:22: of chess or it's stalemate which gets a
00:13:20 - 00:13:24: score of zero
00:13:22 - 00:13:26: now we want to keep track of the best
00:13:24 - 00:13:29: evaluation so over here we can see
00:13:26 - 00:13:30: what evaluation each move leads to and
00:13:29 - 00:13:32: this negative sign
00:13:30 - 00:13:33: is very important because a position
00:13:32 - 00:13:34: that's good for our opponent is bad for
00:13:33 - 00:13:37: us
00:13:34 - 00:13:39: and vice versa let's visualize quickly
00:13:37 - 00:13:41: what's going on
00:13:39 - 00:13:43: so say it's black's turn in the current
00:13:41 - 00:13:45: position and we're trying to choose
00:13:43 - 00:13:47: between three possible moves
00:13:45 - 00:13:49: to do that the search will look at
00:13:47 - 00:13:49: white's possible responses to those
00:13:49 - 00:13:52: moves
00:13:49 - 00:13:54: and evaluate the resulting positions
00:13:52 - 00:13:54: obviously we could search deeper than
00:13:54 - 00:13:57: that but
00:13:54 - 00:13:59: let's keep things simple so these three
00:13:57 - 00:14:00: positions will be evaluated first
00:13:59 - 00:14:02: and from that we can see that white
00:14:00 - 00:14:05: should make this move which gives a
00:14:02 - 00:14:07: score of six in white's favor
00:14:05 - 00:14:08: then these three will be evaluated and
00:14:07 - 00:14:11: white's best option
00:14:08 - 00:14:12: is this move and finally these three are
00:14:11 - 00:14:15: all in black's favor
00:14:12 - 00:14:16: but this move is white's least worst
00:14:15 - 00:14:18: option
00:14:16 - 00:14:20: so in the original position we can now
00:14:18 - 00:14:22: see that black should play this move
00:14:20 - 00:14:25: to ensure an advantage even if white
00:14:22 - 00:14:26: makes the best response
00:14:25 - 00:14:29: now there's a trick for speeding this up
00:14:26 - 00:14:30: if we rewind to this moment
00:14:29 - 00:14:32: here we've just evaluated a position
00:14:30 - 00:14:33: that's good for white
00:14:32 - 00:14:35: in fact it's even better than what white
00:14:33 - 00:14:37: was able to get over here
00:14:35 - 00:14:39: so if you think about it that actually
00:14:37 - 00:14:40: already rules out this move as an option
00:14:39 - 00:14:42: for black
00:14:40 - 00:14:44: and so we can take out our garden shears
00:14:42 - 00:14:47: and prune this branch from the tree
00:14:44 - 00:14:48: not wasting any more time on it this
00:14:47 - 00:14:50: optimization is called
00:14:48 - 00:14:52: alpha beta pruning and it gives the
00:14:50 - 00:14:56: exact same results as a pure search
00:14:52 - 00:14:57: just faster how much faster depends on
00:14:56 - 00:14:59: the order of the moves
00:14:57 - 00:15:01: because if by some misfortune they
00:14:59 - 00:15:03: happen to be ordered from worst to best
00:15:01 - 00:15:05: we can't prune anything at all
00:15:03 - 00:15:06: essentially the more good moves are
00:15:05 - 00:15:08: searched early on
00:15:06 - 00:15:10: the more branches will be pruned and the
00:15:08 - 00:15:12: faster it will be
00:15:10 - 00:15:13: obviously we don't know in advance which
00:15:12 - 00:15:15: moves are good that's the entire reason
00:15:13 - 00:15:18: we're doing the search
00:15:15 - 00:15:20: but we can make some guesses
00:15:18 - 00:15:22: for example if we're able to capture a
00:15:20 - 00:15:24: piece of high value
00:15:22 - 00:15:26: say the opponent's queen with something
00:15:24 - 00:15:29: of low value like a pawn that's very
00:15:26 - 00:15:31: likely to be a good move
00:15:29 - 00:15:33: also promoting a pawn is usually a good
00:15:31 - 00:15:35: idea whereas moving a piece to a square
00:15:33 - 00:15:39: that's attacked by an enemy pawn
00:15:35 - 00:15:39: is usually going to be a bad idea
00:15:39 - 00:15:42: so let's try all of this out on this
00:15:41 - 00:15:44: test position
00:15:42 - 00:15:46: i've set it up to search to a depth of
00:15:44 - 00:15:48: four so it's looking ahead
00:15:46 - 00:15:50: two moves for each side and with just
00:15:48 - 00:15:52: the pure unoptimized search
00:15:50 - 00:15:53: that took a little over a second and it
00:15:52 - 00:15:56: had to evaluate about three and a half
00:15:53 - 00:15:58: million positions
00:15:56 - 00:16:00: i'll now go back and try this again with
00:15:58 - 00:16:01: alpha beta pruning enabled
00:16:00 - 00:16:04: and this time it finished in under a
00:16:01 - 00:16:05: quarter of a second and only evaluated
00:16:04 - 00:16:08: about a half a million positions
00:16:05 - 00:16:10: for the exact same result let's do this
00:16:08 - 00:16:13: one more time now with the move ordering
00:16:10 - 00:16:14: optimization enabled
00:16:13 - 00:16:16: this is brought it all the way down to
00:16:14 - 00:16:18: 25 milliseconds
00:16:16 - 00:16:20: and it only had to evaluate about 5000
00:16:18 - 00:16:21: positions this time
00:16:20 - 00:16:23: i actually wasn't expecting it to be
00:16:21 - 00:16:25: quite that effective so that's really
00:16:23 - 00:16:27: cool to see
00:16:25 - 00:16:30: anyway it does play a lot better than
00:16:27 - 00:16:31: random now but still pretty terribly
00:16:30 - 00:16:33: the trouble is when it reaches the
00:16:31 - 00:16:35: maximum depth of the search it adds up
00:16:33 - 00:16:36: the pieces to see who's ahead
00:16:35 - 00:16:38: but of course that could change on the
00:16:36 - 00:16:39: very next move if there's an unprotected
00:16:38 - 00:16:41: piece somewhere
00:16:39 - 00:16:43: so it's catastrophically misjudging
00:16:41 - 00:16:46: almost every situation
00:16:43 - 00:16:48: the fact is our evaluation function is
00:16:46 - 00:16:50: only going to be remotely reliable
00:16:48 - 00:16:51: if no piece can be captured on the next
00:16:50 - 00:16:53: move
00:16:51 - 00:16:55: so in our search function instead of
00:16:53 - 00:16:56: just evaluating once the depth is
00:16:55 - 00:16:58: reached
00:16:56 - 00:16:59: we can start a new search that looks
00:16:58 - 00:17:01: only at captures
00:16:59 - 00:17:03: and just keeps going until no captures
00:17:01 - 00:17:04: are left
00:17:03 - 00:17:06: here's what that function looks like
00:17:04 - 00:17:06: it's very similar to the regular search
00:17:06 - 00:17:08: with
00:17:06 - 00:17:10: a few small tweaks like of course we're
00:17:08 - 00:17:13: now only generating capture moves
00:17:10 - 00:17:15: and there's no depth limit anymore it
00:17:13 - 00:17:16: might be a good idea to include checks
00:17:15 - 00:17:17: as well in this function but
00:17:16 - 00:17:20: i'm not going to worry about that for
00:17:17 - 00:17:21: now just to get a better feel for what's
00:17:20 - 00:17:23: going on
00:17:21 - 00:17:24: here's the position we had earlier and
00:17:23 - 00:17:26: here are some examples of positions that
00:17:24 - 00:17:28: were evaluated
00:17:26 - 00:17:30: during the original search as you can
00:17:28 - 00:17:32: see there are captures possible
00:17:30 - 00:17:34: all over the place with the addition of
00:17:32 - 00:17:36: that secondary search though
00:17:34 - 00:17:38: the final positions being evaluated now
00:17:36 - 00:17:40: have no immediate captures available
00:17:38 - 00:17:44: so hopefully the evaluations will be a
00:17:40 - 00:17:45: lot closer to the truth
00:17:44 - 00:17:47: now there are still many aspects of the
00:17:45 - 00:17:48: game that the computer is completely
00:17:47 - 00:17:50: hopeless at
00:17:48 - 00:17:51: for example here's a position with a
00:17:50 - 00:17:53: lone king versus two rooks
00:17:51 - 00:17:55: which is of course easily winning for
00:17:53 - 00:17:57: black the trouble is the computer can't
00:17:55 - 00:17:58: see far enough ahead to find a forced
00:17:57 - 00:18:00: checkmate
00:17:58 - 00:18:02: and there are obviously no pieces it can
00:18:00 - 00:18:03: try win so it just shuffles around
00:18:02 - 00:18:05: aimlessly
00:18:03 - 00:18:07: so i've added this little function to
00:18:05 - 00:18:09: the evaluation script
00:18:07 - 00:18:11: which just favors positions where the
00:18:09 - 00:18:12: opponent's king is close to the edge or
00:18:11 - 00:18:14: corner of the board
00:18:12 - 00:18:17: because it should be easier to deliver
00:18:14 - 00:18:19: checkmate there and it also incentivizes
00:18:17 - 00:18:22: moving the king closer to the opponent's
00:18:19 - 00:18:23: king to help cut off its escape routes
00:18:22 - 00:18:25: and assist with the checkmate if
00:18:23 - 00:18:26: necessary this only really applies to
00:18:25 - 00:18:29: the end game though
00:18:26 - 00:18:30: so this value increases in significance
00:18:29 - 00:18:33: as the opponent has
00:18:30 - 00:18:35: fewer and fewer pieces remaining let's
00:18:33 - 00:18:37: see if this actually helps
00:18:35 - 00:18:38: so black has used the rook to cut me off
00:18:37 - 00:18:40: and has now brought the king a little
00:18:38 - 00:18:42: closer
00:18:40 - 00:18:44: now a check to force me to the edge and
00:18:42 - 00:18:46: that's already checkmate
00:18:44 - 00:18:47: i'll make it a bit harder by removing
00:18:46 - 00:18:49: one of black's rocks so now the computer
00:18:47 - 00:18:50: will actually need the king to deliver
00:18:49 - 00:18:52: mate
00:18:50 - 00:18:53: let's see how the machine goes about
00:18:52 - 00:18:55: this
00:18:53 - 00:18:57: it seems to be doing a very good job of
00:18:55 - 00:18:58: forcing me to the edge and
00:18:57 - 00:19:01: now a clever little retreat with the
00:18:58 - 00:19:03: rook and it's mate once again
00:19:01 - 00:19:04: let's try something different here black
00:19:03 - 00:19:06: is up a queen but
00:19:04 - 00:19:08: i'm on the verge of creating a queen of
00:19:06 - 00:19:10: my own so black gives a check
00:19:08 - 00:19:11: and my fear is that it will just keep
00:19:10 - 00:19:15: giving checks forever and
00:19:11 - 00:19:17: end up in a draw but actually it does
00:19:15 - 00:19:18: seem to be maneuvering the queen closer
00:19:17 - 00:19:20: and closer to my king
00:19:18 - 00:19:22: and now it lands on a very important
00:19:20 - 00:19:24: square because i can't move the king
00:19:22 - 00:19:26: away here or else i'll lose my pawn
00:19:24 - 00:19:28: so i'm forced to step in front of it
00:19:26 - 00:19:30: blocking its stream of promotion
00:19:28 - 00:19:32: now the black king has a moment to creep
00:19:30 - 00:19:33: forward and when i move away to allow
00:19:32 - 00:19:35: the pawn to promote
00:19:33 - 00:19:36: black will hopefully lead me on this
00:19:35 - 00:19:38: unpleasant little dance again
00:19:36 - 00:19:40: where i'll be forced to step back in
00:19:38 - 00:19:40: front of the pawn and this should
00:19:40 - 00:19:42: continue
00:19:40 - 00:19:45: until the black king is close enough to
00:19:42 - 00:19:47: help deliver checkmate
00:19:45 - 00:19:48: so this seems to be working and i think
00:19:47 - 00:19:50: it's really cool that that simple tweak
00:19:48 - 00:19:52: to the evaluation function
00:19:50 - 00:19:53: enables it to solve quite a variety of
00:19:52 - 00:19:55: end game positions
00:19:53 - 00:19:56: of course there's still many more
00:19:55 - 00:19:57: complex ones that are beyond its
00:19:56 - 00:20:00: abilities at the moment
00:19:57 - 00:20:02: but this feels like a good start
00:20:00 - 00:20:04: here is an example of a much more
00:20:02 - 00:20:06: complex end game
00:20:04 - 00:20:08: white is winning we just need to sneak
00:20:06 - 00:20:11: our king into black's half of the board
00:20:08 - 00:20:12: to gobble up some pawns
00:20:11 - 00:20:14: this is easier said than done though
00:20:12 - 00:20:15: because playing this against stockfish
00:20:14 - 00:20:17: here you can see that black is able to
00:20:15 - 00:20:19: block our king from entering
00:20:17 - 00:20:21: and if we head over to the other side
00:20:19 - 00:20:23: we'll find our attempts thwarted there
00:20:21 - 00:20:23: as well
00:20:25 - 00:20:28: the truth is that after my very first
00:20:27 - 00:20:31: move the position was already
00:20:28 - 00:20:32: unwinnable white needs to find a very
00:20:31 - 00:20:34: precise path
00:20:32 - 00:20:35: starting with this move to outmaneuver
00:20:34 - 00:20:37: the rival king
00:20:35 - 00:20:39: to solve positions like this our program
00:20:37 - 00:20:41: needs to be able to look very far into
00:20:39 - 00:20:41: the future
00:20:42 - 00:20:46: so let's consider the concept of
00:20:44 - 00:20:48: transpositions
00:20:46 - 00:20:50: which are identical positions reached by
00:20:48 - 00:20:52: different sequences of moves
00:20:50 - 00:20:54: currently we're wasting a lot of time
00:20:52 - 00:20:54: searching and evaluating these identical
00:20:54 - 00:20:56: positions
00:20:54 - 00:20:57: when we could just store the results of
00:20:56 - 00:21:00: the position the first time
00:20:57 - 00:21:01: and look it up if we encounter it again
00:21:00 - 00:21:02: now
00:21:01 - 00:21:04: we can look up positions based on their
00:21:02 - 00:21:05: fend string of course
00:21:04 - 00:21:07: but these are relatively slow to
00:21:05 - 00:21:09: generate and compare
00:21:07 - 00:21:11: so instead i'm going to use a technique
00:21:09 - 00:21:12: called zobrist hashing
00:21:11 - 00:21:15: which is just a quick way of generating
00:21:12 - 00:21:18: a single number to represent a position
00:21:15 - 00:21:19: i'm using a 64-bit number which means
00:21:18 - 00:21:21: there are over 18
00:21:19 - 00:21:22: quintillion possible values we can have
00:21:21 - 00:21:24: which sounds like a lot
00:21:22 - 00:21:26: but that's peanuts to the number of
00:21:24 - 00:21:28: possible chess positions
00:21:26 - 00:21:30: so with this approach we do run a risk
00:21:28 - 00:21:32: of looking up an evaluation and
00:21:30 - 00:21:34: unknowingly getting the result of a
00:21:32 - 00:21:36: completely unrelated position
00:21:34 - 00:21:37: what we can do about this is pretty much
00:21:36 - 00:21:39: nothing
00:21:37 - 00:21:42: if we want the speed we have to live in
00:21:39 - 00:21:44: fear it should be pretty rare though
00:21:42 - 00:21:45: so let's go back to this end game
00:21:44 - 00:21:48: position and i'm going to play the black
00:21:45 - 00:21:50: side now against our little ai
00:21:48 - 00:21:52: i'll give it one second to think and it
00:21:50 - 00:21:53: has found the correct starting move at
00:21:52 - 00:21:54: least
00:21:53 - 00:21:56: i hope this is going to work because the
00:21:54 - 00:21:58: hashing and transposition lookup stuff
00:21:56 - 00:21:59: was a real headache to get working and
00:21:58 - 00:22:02: i'm pretty confident there are still
00:21:59 - 00:22:04: some nasty bugs lucking in my code
00:22:02 - 00:22:05: anyway i need to block the white king
00:22:04 - 00:22:06: from entering on this side
00:22:05 - 00:22:08: but our opponent has managed to
00:22:06 - 00:22:10: orchestrate it in such a way that
00:22:08 - 00:22:12: i believe i'm going to be too late to
00:22:10 - 00:22:13: prevent it from sneaking in
00:22:12 - 00:22:18: on the other flank
00:22:13 - 00:22:20: [Music]
00:22:18 - 00:22:22: i think it's doing a really good job
00:22:20 - 00:22:22: here so now while i'm distracted with
00:22:22 - 00:22:25: this pawn
00:22:22 - 00:22:27: it's heading back over to the other side
00:22:25 - 00:22:29: to eat up my other pawns
00:22:27 - 00:22:30: i suspect this wasn't the fastest way to
00:22:29 - 00:22:32: finish things off but
00:22:30 - 00:22:34: it should definitely do the trick my
00:22:32 - 00:22:36: last faint glimmer of hope is to get
00:22:34 - 00:22:38: this pawn storming up the board
00:22:36 - 00:22:39: but it's just too far behind in the race
00:22:38 - 00:22:42: and i think the computers could be able
00:22:39 - 00:22:44: to cut it off pretty easily
00:22:42 - 00:22:46: i am getting very close to promotion
00:22:44 - 00:22:48: although so it needs to be careful
00:22:46 - 00:22:50: oh it actually doesn't care i guess if i
00:22:48 - 00:22:51: make a queen it will simply checkmate me
00:22:50 - 00:22:53: over here
00:22:51 - 00:22:54: i have one last trick up my sleeve i can
00:22:53 - 00:22:56: promote to a night
00:22:54 - 00:22:57: checking the king but it just steps
00:22:56 - 00:22:59: aside and
00:22:57 - 00:23:03: now there's really nothing i can do very
00:22:59 - 00:23:03: cheeky behavior from the computer
00:23:04 - 00:23:08: okay so i'd say the most glaring
00:23:06 - 00:23:09: weakness now is the computer's opening
00:23:08 - 00:23:11: play
00:23:09 - 00:23:13: it just shuffles pieces around because
00:23:11 - 00:23:14: even with all the optimizations we've
00:23:13 - 00:23:16: done it can't seem nearly far enough
00:23:14 - 00:23:16: ahead to know that this will get into
00:23:16 - 00:23:23: trouble
00:23:16 - 00:23:26: sooner or later
00:23:23 - 00:23:28: [Music]
00:23:26 - 00:23:30: so we need to encourage it to put its
00:23:28 - 00:23:32: pieces on reasonable squares
00:23:30 - 00:23:34: and a simple way of doing that is to
00:23:32 - 00:23:35: create a little map of bonuses for each
00:23:34 - 00:23:38: square
00:23:35 - 00:23:40: for the different pieces
00:23:38 - 00:23:41: here's one for knights for example
00:23:40 - 00:23:42: tempting them towards more central
00:23:41 - 00:23:43: locations
00:23:42 - 00:23:46: where they can control a lot of
00:23:43 - 00:23:48: territory and here's one for the king
00:23:46 - 00:23:49: for the early and middle stages of the
00:23:48 - 00:23:51: game
00:23:49 - 00:23:53: suggesting that it shouldn't wander too
00:23:51 - 00:23:55: far from home and that it might find the
00:23:53 - 00:23:56: most safety towards the outer edges of
00:23:55 - 00:23:57: the board
00:23:56 - 00:24:00: obviously these maps are very
00:23:57 - 00:24:01: generalized and good squares will depend
00:24:00 - 00:24:02: on where your other pieces are and of
00:24:01 - 00:24:03: course
00:24:02 - 00:24:06: where the opponent's pieces are and so
00:24:03 - 00:24:09: on but this should be a helpful nudge in
00:24:06 - 00:24:09: the right direction at least
00:24:09 - 00:24:12: to test this out i'll try making some
00:24:11 - 00:24:14: opening moves again
00:24:12 - 00:24:16: and it seems to be responding a lot more
00:24:14 - 00:24:18: sensibly now than it was before
00:24:16 - 00:24:20: it's bringing out pieces and taking some
00:24:18 - 00:24:23: sort of control in the center
00:24:20 - 00:24:25: so that's very nice to see now it will
00:24:23 - 00:24:27: respond the exact same way every time
00:24:25 - 00:24:28: which is a little dull
00:24:27 - 00:24:31: so to inject some variety i've
00:24:28 - 00:24:33: downloaded a bunch of grandmaster games
00:24:31 - 00:24:35: and for the first five or so moves i'd
00:24:33 - 00:24:37: like the computer to pick a random move
00:24:35 - 00:24:38: from these games to play
00:24:37 - 00:24:40: if it can find the current position in
00:24:38 - 00:24:42: there of course
00:24:40 - 00:24:43: this collection of games is pretty small
00:24:42 - 00:24:45: there are only about 8 000
00:24:43 - 00:24:47: or 7 here but it should be enough for
00:24:45 - 00:24:51: now to give a decent variety of options
00:24:47 - 00:24:53: at least in common opening variations
00:24:51 - 00:24:55: all right now i set myself a deadline
00:24:53 - 00:24:56: for this project which i've actually
00:24:55 - 00:24:58: already exceeded by several weeks
00:24:56 - 00:25:00: it turns out chess programming is quite
00:24:58 - 00:25:02: the rabbit hole so even though there's a
00:25:00 - 00:25:03: million things i still want to do
00:25:02 - 00:25:05: i'm going to stop adding stuff at least
00:25:03 - 00:25:06: for now and let's finally play some
00:25:05 - 00:25:10: games
00:25:06 - 00:25:10: to see how good our little adversary has
00:25:12 - 00:25:15: become
00:25:17 - 00:25:22: so black has played the nimzo indian and
00:25:20 - 00:25:24: i never really know what to do here
00:25:22 - 00:25:25: i'm going to try this it's a bit of a
00:25:24 - 00:25:27: strange looking move but i saw it
00:25:25 - 00:25:29: recommended in a video by grandmaster
00:25:27 - 00:25:31: daniel neroditsky
00:25:29 - 00:25:31: so if this goes badly i at least know
00:25:31 - 00:25:33: who to blame
00:25:31 - 00:25:35: [Music]
00:25:33 - 00:25:36: actually i think i'm already messing
00:25:35 - 00:25:38: this opening up to be honest but
00:25:36 - 00:25:40: the computer is out of its opening book
00:25:38 - 00:25:42: now so it'll have to figure things out
00:25:40 - 00:25:43: on its own as well
00:25:42 - 00:25:45: i should probably focus on getting my
00:25:43 - 00:25:47: king side pieces developed so that i can
00:25:45 - 00:25:49: castle to safety
00:25:47 - 00:25:51: let me just capture here quickly first
00:25:49 - 00:25:56: and defend my night
00:25:51 - 00:26:01: thank you for a very enjoyable game
00:25:56 - 00:26:01: [Music]
00:26:07 - 00:26:11: so as i tried to take my revenge here i
00:26:09 - 00:26:13: want to talk about an interesting
00:26:11 - 00:26:15: problem that i glossed over earlier
00:26:13 - 00:26:17: the problem is how do we decide what
00:26:15 - 00:26:19: depth to search to
00:26:17 - 00:26:20: because obviously we want to search as
00:26:19 - 00:26:22: deeply as possible
00:26:20 - 00:26:23: but we have to take time constraints
00:26:22 - 00:26:25: into account
00:26:23 - 00:26:27: now it's impossible to predict how long
00:26:25 - 00:26:29: a search is going to take
00:26:27 - 00:26:30: and if we stop the search before it's
00:26:29 - 00:26:32: finished the results will be pretty
00:26:30 - 00:26:33: meaningless because it won't have
00:26:32 - 00:26:35: considered all of the opponent's
00:26:33 - 00:26:37: responses yet
00:26:35 - 00:26:38: when i was researching this problem i
00:26:37 - 00:26:40: was initially a bit horrified by the
00:26:38 - 00:26:43: solution i came across
00:26:40 - 00:26:44: but it's actually really clever it has a
00:26:43 - 00:26:46: slightly scary name
00:26:44 - 00:26:47: iterative deepening but the idea is
00:26:46 - 00:26:50: super simple
00:26:47 - 00:26:51: we first do a search to a depth of one
00:26:50 - 00:26:53: and when that's complete we then do a
00:26:51 - 00:26:56: search to a depth of two
00:26:53 - 00:26:58: then three and so on so this way we can
00:26:56 - 00:27:00: of course interrupt it at any time
00:26:58 - 00:27:02: and just use the results from the last
00:27:00 - 00:27:04: fully completed search
00:27:02 - 00:27:07: the reason i was horrified though is
00:27:04 - 00:27:09: that each time we start a deeper search
00:27:07 - 00:27:11: we're redoing the work of all the
00:27:09 - 00:27:13: previous searches we've done
00:27:11 - 00:27:14: it seems like a huge waste of time
00:27:13 - 00:27:16: especially because we can't even use all
00:27:14 - 00:27:17: the evaluations stored in the
00:27:16 - 00:27:19: transposition table
00:27:17 - 00:27:20: because they're not helpful if they come
00:27:19 - 00:27:22: from a shallower search than we're
00:27:20 - 00:27:25: currently doing
00:27:22 - 00:27:26: but and this is a big but remember that
00:27:25 - 00:27:28: with alpha beta pruning
00:27:26 - 00:27:31: if we look at good moves first it will
00:27:28 - 00:27:33: be able to prune more branches
00:27:31 - 00:27:35: and so what we can do is keep track of
00:27:33 - 00:27:37: the best moves during each search
00:27:35 - 00:27:39: and look at those first in the next
00:27:37 - 00:27:41: deeper search
00:27:39 - 00:27:42: the deeper search won't always agree
00:27:41 - 00:27:44: that those are good moves but a lot of
00:27:42 - 00:27:45: the time it will
00:27:44 - 00:27:48: and it turns out that the increased
00:27:45 - 00:27:50: amount of pruning that this leads to
00:27:48 - 00:27:51: means that counterintuitively the
00:27:50 - 00:27:53: iterative approach is often
00:27:51 - 00:27:56: even faster than just doing the whole
00:27:53 - 00:27:57: search once
00:27:56 - 00:27:59: i'm not sure if that explanation made
00:27:57 - 00:28:03: any sense but i hope so because i
00:27:59 - 00:28:06: thought this idea was really interesting
00:28:03 - 00:28:06: [Music]
00:28:07 - 00:28:10: okay so i've played a bunch of games
00:28:09 - 00:28:13: behind the scenes by now
00:28:10 - 00:28:15: and i'm able to win most of the time so
00:28:13 - 00:28:16: the computer obviously has lots of room
00:28:15 - 00:28:18: for improvement
00:28:16 - 00:28:21: in all aspects of the game but i think
00:28:18 - 00:28:23: there are two main weaknesses
00:28:21 - 00:28:24: the first is its very poor understanding
00:28:23 - 00:28:25: of king safety
00:28:24 - 00:28:28: which means it often thinks it's doing
00:28:25 - 00:28:29: fine and then suddenly realizes
00:28:28 - 00:28:32: it actually needs to start sacrificing
00:28:29 - 00:28:34: pieces in order to stave off checkmate
00:28:32 - 00:28:36: the other is its understanding of pawn
00:28:34 - 00:28:37: structure or rather the total lack
00:28:36 - 00:28:39: thereof
00:28:37 - 00:28:40: it likes to advance pawns up the board
00:28:39 - 00:28:42: to try promote them but it has very
00:28:40 - 00:28:44: little ability to judge if a pawn is
00:28:42 - 00:28:45: weak or strong which causes it to
00:28:44 - 00:28:49: happily go
00:28:45 - 00:28:49: into a lot of really bad positions
00:28:52 - 00:28:56: so i'd like to come back to this project
00:28:54 - 00:28:58: at one point to try address these issues
00:28:56 - 00:28:59: and hopefully make it a much more
00:28:58 - 00:29:01: formidable opponent
00:28:59 - 00:29:03: but i think this is an okay start and i
00:29:01 - 00:29:04: definitely had a lot of fun working on
00:29:03 - 00:29:06: it
00:29:04 - 00:29:07: so thanks for watching to anyone who
00:29:06 - 00:29:09: might have made it this far
00:29:07 - 00:29:11: i know it was quite a long journey but i
00:29:09 - 00:29:23: hope you found it interesting
00:29:11 - 00:29:23: until next time cheers
